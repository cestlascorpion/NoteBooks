# KCP - A Fast and Reliable ARQ Protocol

[原帖](https://github.com/skywind3000/kcp/blob/master/README.md)

## 简介

KCP 是一个快速可靠协议，能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如 UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback 的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。课代表总结：KCP 是一个 ARQ 协议，KCP+UDP->TCP。

整个协议只有 ikcp.h, ikcp.c 两个源文件，可以方便的集成到用户自己的协议栈中。也许你实现了一个 P2P，或者某个基于 UDP 的协议，而缺乏一套完善的 ARQ 可靠协议实现，那么简单的拷贝这两个文件到现有项目中，稍微编写两行代码，即可使用。

## 技术特性

TCP 是为流量设计的（每秒内可以传输多少 KB 的数据），讲究的是充分利用带宽。而 KCP 是为流速设计的（单个数据包从一端发送到一端需要多少时间），以 10%-20% 带宽浪费的代价换取了比 TCP 快 30%-40% 的传输速度。TCP 信道是一条流速很慢，但每秒流量很大的大运河，而 KCP 是水流湍急的小激流。

### RTO 翻倍 vs 不翻倍

TCP 超时计算是 RTOx2，这样连续丢三次包就变成 RTOx8 了，十分恐怖，而 KCP 启动快速模式后不 x2，只是 x1.5（实验证明 1.5 这个值相对比较好），提高了传输速度。

### 选择性重传 vs 全部重传

TCP 丢包时会全部重传从丢的那个包开始以后的数据，KCP 是选择性重传，只重传真正丢失的数据包。

### 快速重传

发送端发送了 1, 2, 3, 4, 5 几个包，然后收到远端的 ACK 1, 3, 4, 5，当收到 ACK3 时，KCP 知道 2 被跳过 1 次，收到 ACK4 时，知道 2 被跳过了 2 次，此时可以认为 2 号丢失，不用等超时，直接重传 2 号包，大大改善了丢包时的传输速度。

### 延迟 ACK vs 非延迟 ACK

TCP 为了充分利用带宽，延迟发送 ACK（NODELAY 都没用），这样超时计算会算出较大 RTT 时间，延长了丢包时的判断过程。KCP 的 ACK 是否延迟发送可以调节。

### UNA vs ACK+UNA

ARQ 模型响应有两种，UNA（此编号前所有包已收到，如 TCP）和 ACK（该编号包已收到），光用 UNA 将导致全部重传，光用 ACK 则丢失成本太高，以往协议都是二选其一，而 KCP 协议中，除去单独的 ACK 包外，所有包都有 UNA 信息。

### 非退让流控

KCP 正常模式同 TCP 一样使用公平退让法则，即发送窗口大小由发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取了开着 BT 都能流畅传输的效果。

## 基本使用

创建 KCP 对象：

```c
// 初始化 kcp 对象，conv 为一个表示会话编号的整数，和 tcp 的 conv 一样，通信双
// 方需保证 conv 相同，相互的数据包才能够被认可，user 是一个给回调函数的指针
ikcpcb *kcp = ikcp_create(conv, user);
```

设置回调函数：

```c
// KCP 的下层协议输出函数，KCP 需要发送数据时会调用它
// buf/len 表示缓存和长度
// user 指针为 kcp 对象创建时传入的值，用于区别多个 KCP 对象
int udp_output(const char *buf, int len, ikcpcb *kcp, void *user)
{
   ....
}
// 设置回调函数
kcp->output = udp_output;
```

循环调用 update：

```c
// 以一定频率调用 ikcp_update 来更新 kcp 状态，并且传入当前时钟（毫秒单位）
// 如 10ms 调用一次，或用 ikcp_check 确定下次调用 update 的时间不必每次调用
ikcp_update(kcp, millisec);
```

输入一个下层数据包：

```c
// 收到一个下层数据包（比如 UDP 包）时需要调用：
ikcp_input(kcp, received_udp_packet, received_udp_size);
```

处理了下层协议的输出 / 输入后 KCP 协议就可以正常工作了，使用 ikcp_send 来向远端发送数据。而另一端使用 ikcp_recv(kcp, ptr, size) 来接收数据。

课代表：回调函数函数基本上就是 sendto() 包装后的结果。发送数据时调用 ikcp_send() 向 kcp 中丢数据，kcp 处理后会调用回调函数将 kcp 包发出去；对端接收到数据后（一般就是 UDP 包），调用 ikcp_input() 向 kcp 中丢数据，然后再调用 ikcp_recv() 接收 kcp 处理过的数据（也是发送端最开始向 kcp 中丢的数据），至此数据收发完成。因为收发端需要不断的相互发送 kcp 包，而这个频率和上层的收发并不是步调一致的，需要周期性调用 ikcp_update() 来驱动这个过程。

## 协议配置

协议默认模式是一个标准的 ARQ，需要通过配置打开各项加速开关：

工作模式：

```c
int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)
```

>- nodelay ：是否启用 nodelay 模式，0 不启用；1 启用。
>- interval ：协议内部工作的 interval，单位毫秒，比如 10ms 或者 20ms
>- resend ：快速重传模式，默认 0 关闭，可以设置 2（2 次 ACK 跨越将会直接重传）
>- nc ：是否关闭流控，默认是 0 代表不关闭，1 代表关闭
>- 普通模式： ikcp_nodelay(kcp, 0, 40, 0, 0);
>- 极速模式： ikcp_nodelay(kcp, 1, 10, 2, 1);

最大窗口：

```c
int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);
```

该调用将会设置协议的最大发送窗口和最大接收窗口大小，默认为 32。这个可以理解为 TCP 的 SND_BUF 和 RCV_BUF，只不过单位不一样 SND/RCV_BUF 单位是字节，这个单位是包。

最大传输单元：

纯算法协议并不负责探测 MTU，默认 mtu 是 1400 字节，可以使用 ikcp_setmtu 来设置该值。该值将会影响数据包归并及分片时候的最大传输单元。

最小 RTO：

不管是 TCP 还是 KCP 计算 RTO 时都有最小 RTO 的限制，即便计算出来 RTO 为 40ms，由于默认的 RTO 是 100ms，协议只有在 100ms 后才能检测到丢包，快速模式下为 30ms，可以手动更改该值：

```c
kcp->rx_minrto = 10;
```

## 学习

UDP 收到的包，不断通过 kcp_input 喂给 KCP，KCP 会对这部分数据（KCP 协议数据）进行解包，重新封装成应用层用户数据，应用层通过 kcp_recv 获取。应用层通过 kcp_send 发送数据，KCP 会把用户数据拆分 kcp 数据包，通过 kcp_output，以 UDP（send）的方式发送。

KCP 是一个可靠的传输协议，UDP 本身是不可靠的，所以需要额外信息来保证传输数据的可靠性。因此，我们需要在传输的数据上增加一个包头。用于确保数据的可靠、有序。

0                    4    5    6         8 (BYTE)

+-------------------+----+----+--------+

|       conv        |cmd |frg |wnd     |

+-------------------+----+----+--------+ 8

|         ts        |        sn        |

+-------------------+------------------+ 16

|         una       |        len       |

+-------------------+------------------+ 24

|                                      |

|            DATA (optional)           |

|                                      |

+--------------------------------------+

conv: 连接号。UDP 是无连接的，conv 用于表示来自于哪个客户端。对连接的一种替代。
cmd: 命令字。如 IKCP_CMD_ACK 确认命令，IKCP_CMD_WASK 接收窗口大小询问命令，IKCP_CMD_WINS 接收窗口大小告知命令。
frg: 分片，用户数据可能会被分成多个 KCP 包发送出去，序号从大到小，0 号表示最后一个。
wnd: 接收窗口大小，发送方的发送窗口不能超过接收方给出的数值。
ts: 时间序列。
sn: 序列号。
una: 下一个可接收的序列号。其实就是确认号，收到 sn=10 的包，una 为 11。
len：数据长度。
data: 用户数据。
