# libshmcache

libshmcache 是基于共享内存的本地缓存库，可以在多个非亲缘关系的进程间共享缓存。libshmcache 写有锁，读无锁，性能非常高。libshmcache 直接访问本地共享内存，速度比远程接口如 redis 快 100 倍以上。

为什么 libshmcache 快：读无锁，同时也不完全保证调用者能够读到完整的数据（只有缓存的数据较大时才有可能出现脏读）。

## 高性能特性

>- 写采用 pthread 互斥锁，读无锁；
>- 使用 hash table 进行快速 set、get 和 delete；
>- 使用对象池（FIFO 队列）对 hash table 键值对进行分配；
>- value buffer 分配使用 striping（条带化）分配机制，在 striping 内按顺序分配 buffer。当释放 value buffer 时，只需要减少 striping 已使用空间（used size）。释放 value buffer 后，若 striping 已使用空间变为 0，回收整个 striping；
>- 淘汰算法使用简单高效的 FIFO 而不是 LRU（因为 LRU 在读命中时需要修改一些数据结构，设计无锁的难度较大）。

## 稳定性特性

>- 死锁检测和自动解锁机制。死锁发生场景：正在修改数据的进程挂掉，会导致死锁；
>- 初始化时检查一些关键字段的一致性，当内存相关的参数发生变化时，系统会自动提示共享内存需要清理和重新初始化；
>- 当回收了有效的（未过期）键值对时，休眠一定时长以避免其他进程读到脏数据（调用者要尽快取走数据）。

## 其他特性

>- 除了支持有亲缘关系的进程（如父进程和子进程），还支持无亲缘关系的进程（如 PHP FPM 进程和 PHP CLI 进程，多个 PHP CLI 进程等等）；
>- 按需增量分配 value buffer，有效减少初始内存大小，避免内存浪费（通过配置参数 segment_size 来设置）；
>- 提供丰富的统计信息：get，set 和 delete 次数统计、缓存命中率、内存回收统计、锁使用统计等；
>- 支持原子增加（减少）；
>- PHP 扩展支持多种序列化方式：igbinary、msgpack、PHP 序列化，以及无需序列化。因为键值对中存储了所用的序列化方式，这几种序列化方式可以并存；

友情提示：key 长度不能超过 64 字节。

## 使用场景

如果需要缓存的数据量不是太大，比如不超过 100w 个 key，对缓存读写性能要求又比较高的情况下，可以考虑使用 libshmcache。总结为一句话：追求极致性能，以空间换时间。
