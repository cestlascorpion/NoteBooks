# 后台开发读书笔记

## 第四章 编译

编译和链接的过程可以分解为4个步骤，分别是

预处理(Prepressing) -> 编译(Compilation) -> 汇编(Assembly) -> 链接(Linking)。

### 预处理

源文件example.cpp和相关头文件被预处理器预处理为一个.i文件。

```shell
g++ -E example.cpp -o example.i // -E 表示只进行预处理
```

预处理主要是处理源文件中#开始的预编译指令。经过预编的文件不含任何宏定义，被包含的文件被插入到.i文件中。

>- 将所有的#define/#undef删除，展开所有的宏定义。
>- 处理所有的条件预编译指令，如#if #ifdef #elif #else #endif等，将不必要的代码过滤掉。
>- 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置，这个过程是递归进行的。
>- 过滤所有的注释内容。
>- 添加行号和文件名标识，如#2 "test.c"2，以便编译时编译器产生调试用的行号信息以及用于编译时产生变异错误/警告时能够显示行号。
>- 保留所有的#pragma编译指令，因为编译器需要使用它们。

### 编译

编译的过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析以及优化后产生相应的汇编代码文件，是程序构建的核心和最为复杂的部分。

```shell
g++ -S example.i -o example.s // -S表示只执行到源代码到汇编代码的转换，输出汇编代码
```

从直观角度来讲，编译器就是将高级语言翻译成机器语言的一个工具。比如用c/c++编写的一个程序被编译器翻译成机器可以只从的指令及数据。编译一边分6步：

>- 源代码--(词法分析)-->
>- 产生了一堆单词token--(语法分析)-->
>- 语法树--(语义分析)-->
>- 带变量的语法树--(源代码优化)-->
>- 中间语言--(代码生成)-->
>- 目标代码--(目标代码优化)-->
>- 最终目标代码

### 汇编

将编译完的汇编代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件，字节编码是机器指令。

汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可。

### 链接

定义其他模块的全局变量和函数在最终运行时的绝对地址在最终链接的时候才能确定。现代编译器可以将一个源文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。链接的主要内容就是把各个模块之间的相互引用的部分处理好，使得各个模块之间能够正确的衔接。链接主要包括了地址和空间分配、符号决议和重定位等步骤。

库其实就是一组目标文件的包，就是一些最常用的代码编译成目标文件后打包存放。

每个目标文件除了拥有自己的数据和二进制代码外，还提供了三个表：

>- 未解决符号表：提供了所有在该编译单元里引用但是定义并不在本编译单元的符号及其出现的地址
>- 导出符号表：提供了本编译单元具有定义但是愿意提供给其他编译单元使用的符号及其地址
>- 地址重定向表：提供了本编译单元所有对自身地址的引用的记录

编译器将extern声明的变量置入未解决符号表，属于外部链接。static声明的全局变量不置入未解决符号表，也不置入导出符号表，因此其他单元无法使用，属于内部链接（static的隐藏）。普通变量及其函数被置入导出符号表。

链接分为静态链接和动态链接。对函数库的链接是放在编译时期完成的，是静态链接。所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。程序运行时不再需要函数库。这种函数库被称为静态库，通常文件名为"libxxx.a"的形式。库文件的命名规范是以lib开头，紧接着是静态库名，以.a为后缀名。

```shell
# 假设有这样五个文件：add.h add.cpp sub.h sub.cpp main.cpp

# 将add.cpp，sub.cpp编译成.o文件
g++ -c add.cpp
g++ -c sub.cpp
# 生成add.o和sub.o，-c表示只执行到编译，输出目标文件
# 无论是静态库文件还是动态库文件都是由.o文件创建的

# .o文件创建静态库文件.a
ar cr libmymath.a add.o sub.o
# ar命令可以显示库文件.a包含的.o文件及其详细信息
ar tv libmymath.a

# 在程序中使用静态库
g++ -o main main.cpp -L. -lmymath
# 静态库使用：需要在用到这些公用函数的源程序中包含这些公用函数的原型声明
# 然后在用g++命令生成目标文件时指明静态库名（mymath而非libmymath）

# 在程序中使用动态库
g++ -fPIC -add.o -c add.cpp
g++ -shared -o libmymath.so add.o。
# 上述命令也可以写作
g++ -fPIC -shared -o libmymath.so add.cpp
```

其他常见编译参数：

>- -fPIC：表示编译为位置独立的代码
>- -Lpath：表示在path目录中搜索库文件，如-L.则表示在当前目录搜索
>- -Ipath：表示在path目录中搜索头文件
>- -Itest：编译器查找动态链接库时隐含的命名规则，即lib+库名+.so

在程序中隐式使用动态库和静态库完全一样。如果执行时会报错找不到库，需要将libmymath.a复制到/usr/lib中。或/和修改环境变量LD_LIBRARY_PATH。

```shell
g++ -o main mian.cpp -L. -lmymath
```

动态库的搜索路径搜索顺序是：

>- 编译目标代码时指定的动态库搜索路径
>- 环境变量LD_LIBRARY_PATH指定的动态库搜索路径
>- 配置文件/etc/ld.so.conf中指定的动态库搜索路径，可以在文件中追加路径然后ldconfig使修改生效
>- 默认的动态库搜索路径/lib
>- 默认的动态库搜索路径/usr/lib

减少目标文件大小的工具——strip。strip命令可以从ELF文件中有选择性地除去行号信息、重定位信息、调试段、typchk段、注释段、文件头以及所有或者部分符号表。通常只在已经调试和测试过的生成模块上使用strip命令。

#### 静态/动态链接库

动态链接库有利于进程间资源共享。当某个程序需要调用某个动态链接库时现在内存中查找有没有此库函数的拷贝。如果有则让其共享同一个拷贝，没有则链接载入，节省内存资源。甚至可以真正做到链接载入完全由程序员在代码中控制。采用动态链接库使程序升级变得简单。只要动态库提供的接口不变，只要重新生成动态库即可。由于静态库在编译的时候，就将库函数装载到程序中了，而动态库函数必须在运行的时候才被装载，所以程序在执行的时候用静态库的速度更快。

#### g++和gcc的区别

g++和gcc都能编译c/c++代码。

后缀为.c的文件，gcc会将其当作c程序，g++会将其当作c++程序。后缀为.cpp的文件都被当作c++程序。而c和c++的语法上还是有区别的。c++语法更严谨一些。编译阶段，g++会调用gcc，对于c++代码代码二者是等价的。但是gcc命令不能自动和c++程序使用的库链接，所以通常用g++来完成链接（或者gcc -lstdc++）。为了统一起见，索性编译连接都用g++。gcc在编译.c文件时，_cplusplus时未定义的。另外extern "C"和gcc/g++没有关系。

#### 调试选项

>- -g: 只是编译器，在编译的时候，产生调试信息
>- -gstabs: 此选项以stabs格式声称调试信息,但是不包括gdb调试信息
>- -gstabs+: 此选项以stabs格式声称调试信息,并且包含仅供gdb使用的额外调试信息
>- -ggdb: 此选项将尽可能的生成gdb的可以使用的调试信息
>- -glevel: 请求生成调试信息，同时用level指出需要多少信息，默认的level值是2

#### 错误与警告选项

>- -Wall 一般使用该选项，允许发出GCC能够提供的所有有用的警告。也可以用-W{warning}来标记指定的警告
>- -pedantic 允许发出ANSI/ISO C标准所列出的所有警告
>- -pedantic-errors 允许发出ANSI/ISO C标准所列出的错误
>- -werror 把所有警告转换为错误，以在警告发生时中止编译过程
>- -w 关闭所有警告,建议不要使用此项

-Wall包括

>- -Waddress
>- -Warray-bounds=1 (only with -O2)  
>- -Wc++11-compat  -Wc++14-compat
>- -Wchar-subscripts  
>- -Wenum-compare (in C/ObjC; this is on by default in C++)
>- -Wimplicit-int (C and Objective-C only)
>- -Wimplicit-function-declaration (C and Objective-C only)
>- -Wbool-compare  
>- -Wduplicated-cond  
>- -Wcomment  
>- -Wformat
>- -Wmain (only for C/ObjC and unless -ffreestanding)  
>- -Wmaybe-uninitialized
>- -Wmissing-braces (only for C/ObjC)
>- -Wnonnull  
>- -Wopenmp-simd
>- -Wparentheses  
>- -Wpointer-sign  
>- -Wreorder
>- -Wreturn-type  
>- -Wsequence-point  
>- -Wsign-compare (only in C++)  
>- -Wstrict-aliasing  
>- -Wstrict-overflow=1  
>- -Wswitch  
>- -Wtautological-compare  
>- -Wtrigraphs  
>- -Wuninitialized  
>- -Wunknown-pragmas  
>- -Wunused-function  
>- -Wunused-label
>- -Wunused-value
>- -Wunused-variable  
>- -Wvolatile-register-var

-Wextra包括

>- -Wclobbered  
>- -Wempty-body  
>- -Wignored-qualifiers
>- -Wmissing-field-initializers  
>- -Wmissing-parameter-type (C only)  
>- -Wold-style-declaration (C only)  
>- -Woverride-init  
>- -Wsign-compare  
>- -Wtype-limits  
>- -Wuninitialized  
>- -Wshift-negative-value  
>- -Wunused-parameter (only with -Wunused or -Wall)
>- -Wunused-but-set-parameter (only with -Wunused or -Wall)

-Wextra还会检查如下情况

>- A pointer is compared against integer zero with <, <=, >, or >=.
>- (C++ only) An enumerator and a non-enumerator both appear in a conditional expression.
>- (C++ only) Ambiguous virtual bases.
>- (C++ only) Subscripting an array that has been declared register.
>- (C++ only) Taking the address of a variable that has been declared register.
>- (C++ only) A base class is not initialized in the copy constructor of a derived class.

其他警告信息参见[GCC Warning options](http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html)。列举如下几项

>- -Wunused-but-set-variable 设置了但未使用的变量警告
>- -Wunused-label 未使用的标签，比如用goto会使用label，但在删除goto语句时，忘了删除label
>- -Wfloat-equal 对浮点数使用等号，这是不安全的
>- -Wconversion-null
>- -Wsizeof-pointer-memaccess 在sizeof中经常出现，如memset(this, 0, sizeof(this));
>- -Woverflow 范围溢出
>- -Wshadow 局部变量覆盖参数、全局变量

#### ANSI C标准的预定义宏

```shell
__FILE__ : 宏所在文件的源文件名
__LINE__ : 宏所在行的行号
__DATE__ : 代码编译的日期
__TIME__ : 代码编译的时间
__STDC__ : 指示编译器是否执行ANSI C标准，如果是则其值为1
__cplusplus : 编译C++程序时该标识符被定义为1
```

#### makefile的撰写

```makefile
# 假设有这样三个文件：file1.h file1.cpp file2.cpp
# makefile 文件

example:file1.o file2.o
    g++ file1.o file2.o -o example
file2.o:file2.cpp
    g++ -c file2.cpp -o file2.o
file1.o:file1.cpp file1.h
    g++ -c file1.cpp -o file1.o
clean:
    rm -rf *.o example
```

makefile的主要规则

```shell
A：B
(tab)<command>
```

每个命令行前必须有tab符号。编译产出A，其以来文件为B，编译命令为command。-c表示编译成.o文件。-o表示输出文件的文件名。clean表示make clean执行的命令。

```makefile
# 在makefile中使用变量
OBJS = add.o sub.o main.o
XX = g++
CFLAGS = -Wall -O -g

example: $(OBJS)
    $(XX) $(OBJS) -o example
add.o: add.cpp add.h
    $(XX) $(CFLAGS) -c add.cpp -o add.o
sub.o: sub.cpp sub.h
    $(XX) $(CFLAGS) -c sub.cpp -o sub.o
main.o: main.cpp
    $(XX) $(CFLAGS) -c main.cpp -o main.o
clean:
    rm -rf *.o example
```

CFLAGS = -Wall -O -g。-Wall表示输出所有警告信息；-O表示编译时进行优化；-g表示编译debug版本。

```makefile
# 在makefile中使用函数
TARGET = example
XX = g++
CC = gcc
CFLAGS = -Wall -O -g

%.o: %.c
    $(CC) $(CFLAGS) -c $< -o $@
%.o: %.cpp
    $(XX) $(CFLAGS) -c $< -o $@

SOURCES = $(wildcard *.c *.cpp)
OBJS = $(patsubst %.c, %.o, $(patsubst %.cpp, %.o, $(SOURCES)))

$(warning "$(SOURCES)")
$(warning "$(OBJS)")

$(TARGET): $(OBJS)
    $(XX) $(OBJS) -o $(TARGET)
clean:
    rm -rf *.o example

```

$(wildcard pattern...)在makefile中，被展开称为已经存在的、使用空格分开的、匹配此模式的虽有文件列表。如果不存在会忽略模式字符返回空。所以`SOURCES = $(wildcard *.c *.cpp)`表示产生一个所有以.c .cpp结尾的文件的列表，存入变量SOURCES。

patsubst函数用于匹配替换，有3个参数。第一个参数是需要匹配的样式，第二个参数是用什么来替换样式，第三个参数是需要被处理的由空格分隔的列表。如`$(patsubst %.c, %.o, $(dir))`表示用patsubst把$(dir)中变量符合后缀是.c的全部替换为.o。`OBJS = $(patsubst %.c, %.o, $(patsubst %.cpp, %.o, $(SOURCES)))`则把所有的.c .cpp字符变为.o形成一个新的列表存入OBJS变量。

```makefile
%.o: %.c
    $(CC) $(CFLAGS) -c $< -o $@
%.o: %.cpp
    $(XX) $(CFLAGS) -c $< -o $@
```

上述命令表示把所有的.c .cpp文件编译成.o文件。

#### cmakelists.txt

cmake是一个工程构建工具，能够自动生产makefile文件，方便构建编译文件，链接库，安装文件等。

>- 开放源代码，使用类 BSD 许可发布。
>- 简化编译构建过程和编译过程。cmake的工具链非常简单：cmake+make。
>- 跨平台，可生成native编译配置文件，在Linux/Unix生成makefile，在MacOS可以生成 xcode，在Windows生成MSVC的工程文件。
>- 可扩展，可以为cmake编写特定功能的模块，扩充cmake功能。

cmake要使用"cmake语言和语法"去构建。

>- 变量使用${}方式取值，但是在IF控制语句中是直接使用变量名。
>- 参数使用括弧括起，参数之间使用空格或分号分开: 指令 (参数 1 参数 2…)。
>- 指令是大小写无关的，参数和变量是大小写相关的。

```cmake
# 简单的示例
# cmake最低版本需求
cmake_minimum_required(VERSION 3.10)
# 项目信息
project(Novel)

set(CMAKE_CXX_STANDARD 11)
# 添加需要链接的lib文件路径
link_libraries("/usr/local/lib/libgumbo.so")
# 指定生成目标 Novel是目标文件名 其他是编译所需的文件
add_executable(Novel
        src/main.cpp
        src/config.h
        src/test/Test.cpp
        src/test/Test.h
        src/checkhtml/Novel.cpp
        src/checkhtml/Novel.h)
```

假设已经完成了CMakeLists.txt文件的编写，可以执行cmake命令生成Makefile文件了。此时有两种方法可以执行cmake、编译和安装：

```shell
cmake .
make
```

或者

```shell
mkdir build
cd build
cmake ..
make
```

两种方法最大的不同在于执行cmake和make的工作路径不同。第一种方法中，cmake生成的所有中间文件和可执行文件都会存放在项目目录中，称为内部构建；而第二种方法中，中间文件和可执行文件都将存放再build目录中，称为外部构建。cmake强烈推荐使用外部构建的方法。

```cmake
# 之前的example
cmake_minimum_required(VERSION 3.10)
project(Example)
set(CMAKE_CXX_STANDARD 11)

add_executable(
        Example
        main.cpp
        add.h
        add.cpp
        sub.h
        sub.cpp
        )
```