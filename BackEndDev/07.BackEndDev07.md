# 后台开发读书笔记

## 第九章 线程

### 多线程

一个程序在运行过程中，只有一个控制权存在。该函数在被调用时，获得控制权，称为激活函数。与此同时其他函数处于离场状态。多线程就是允许一个进程内存中存在多个控制权，让多个函数处于激活状态，从而让多个函数的操作同时运行。

在以前进程是系统独立调度和分派的基本单位，后面由于多道处理的出现，产生了并发的概念，它加大了系统的容量与对硬件的利用率。对于单处理器的机器来说，实现并发典型的方法便是使用分时，即CPU将时间片按特定算法分发给各个进程，虽然总的计算次数可能并没有发生什么变化，但是由于CPU的计算速度越来越快，从宏观上来看，几个进程就像是在同一时间段内运行的。于是当进程A的时间用完了之后就要切换到另一个进程B，此时计算机需要为进程A保存下结束时的状态以便下一次从上一次结束处继续执行，还需要为进程B的运行做各种准备工作，由于进程相对而言比较大，反复切换会浪费很多的资源，所以人们想能不能将系统独立调度和分派的基本单位做得更小，以减少进程切换所浪费的资源 —— 于是线程出现了。现在，大部分的操作系统都是以线程为系统独立调度和分派的基本单位。另外，进程是由一个或者多个线程组成，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。

### 并发

>- 并发：同一时间段内交替运行多个进程（线程）。
>- 并行：同一时刻运行多个进程（线程）。很明显，只有多处理器才能支持。

多进程并发是将应用程序分为多个独立的进程，它们在同一时刻运行，就像同时进行网页浏览和文字处理一样。独立的进程可以通过进程间常规的通信渠道传递讯息。

>- 缺点：操作系统会在进程间提供了一定的保护措施，以避免一个进程去修改另一个进程的数据。这导致进程之间的通信通常不是设置复杂，就是速度慢；运行多个进程需要时间启动进程，操作系统需要内部资源来管理进程。
>- 优点：操作系统在进程间提供附加的保护操作和更高级别的通信机制，意味着可以更容易编写安全的并发代码；可以使用远程连接的方式，在不同的机器上运行独立的进程。

多线程并发也是并发的另一个途径是在单个进程中运行多个线程。线程类似于轻量级的进程，每个线程相互独立运行，且线程可以在不同的指令序列中运行。

>- 缺点：缺少线程间的数据保护，如果数据要被多个线程访问，我们必须确保每个线程所访问的的数据是一致的，因此需要对线程通信做大量的工作。
>- 优点：进程中所有线程共享地址空间，并且缺少数据保护，使得操作系统的记录工作量减小，所以使用多线程的相关开销远远小于使用多个进程；单一进程中的多线程间的通信开销较小。

利用并发提高性能的方式:

>- 任务并行（易并行）：将一个单个任务分成几部分，并且各自并行运行，从而降低总运行时间。此种方法具有良好的可扩展性，当可用硬件线程的数量增加时，算法的并行性也随之增加。当可用硬件线程的数量增加时，算法的并行性也会随之增加。如果算法中有不易并行的部分，你可以把算法划分成固定（不可扩展）数量的并行任务。
>- 数据并行（可并行）：每个线程在不同的数据部分上执行相同的操作。处理一个数据块仍然需要同样的时间，但在相同的时间内处理了更多的数据。这种方法所带来的吞吐量提升，可以让某些新功能成为可能。

### 多线程编程

### 多线程同步

对于多线程程序来说，同步是指在一定的时间内允许某一线城访问某个资源。而在此时间内，不允许其他线程访问该资源。可以通过互斥锁（mutex），条件变量（condition variable），读写锁（reader-writer lock）和信号量（semphore）来同步资源。

互斥锁是一种特殊的变量，具有锁上（lock）和打开（unlock）两个状态。互斥锁一般设置成全局变量。打开的互斥锁可以由某个线程获得。一旦获得，这个锁就会被锁上，此后只有该线程有权打开锁。其他想要获得互斥锁的线程会等待直到互斥锁再次打开的时候。

条件变量通过允许线程阻塞和等待另一线程发送信号的方法弥补互斥锁的不足，常常和互斥锁一起使用。如果线程正在等待共享数据内某个条件出现，使用互斥锁可能导致对对象频繁的加锁和解锁，每次都要检查共享数据结构以查找某个值。使用条件变量，可以阻塞某一线程。当条件不满足时，线程往往解开相应的互斥锁并等待条件的变化。一旦其他某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或者多个正被此条件变量阻塞的线程，这些线程将重新锁定互斥锁并重新测试条件是否满足。因此条件变量特别适合多个线程等待某个条件发生的情形。如果不使用条件变量，每个线程需要不断地尝试获得互斥锁并检查条件是否满足，浪费系统资源。

读写锁适用于多数据结构的读操作次数多于写操作次数的场合，因为读模式锁定时可以共享，而写模式锁定时只能某个线程独占资源，因此读写锁也被成为共享-独占锁。读写锁比起互斥锁具有更高的适用性与并行性，可以有多线程同事占用读模式的读写锁，但是只能有一个线程占用写模式的读写锁。读写锁是写加锁状态时，任何试图多哦这个锁加锁的线程都被阻塞；读写所是读加锁状态时，所有试图以读模式对它加锁的线程都会得到访问权，以写模式对他加锁的线程都会被阻塞（读写锁通常会阻塞随后的读模式加锁的线程，避免读模式锁长期占用，写模式锁请求长期阻塞）。

不过处理读者-写者问题有两种常见策略：强读者同步和强写者同步。前者总是给读者更高的优先权，只要写者没有进行写操作，读者就可以获得访问权限；后者优先权交付给写者，读者只能等到所有正在等待的或者正在执行的写者结束以后才能执行。

信号量允许多个线程进入临界区，互斥锁只允许一个线程进入。

多线程同步是为了解决“函数不可重入”的问题。可重入函数是指由多于一个任务并发使用，而不必担心数据错误的函数。不可重入函数是指只能由一个任务占用，除非能确保函数的互斥。可重入函数可以在任意时刻被打断，稍后继续运行，且不会丢失数据。

可重入函数的特点：

>- 不为连续的调用持有静态数据；
>- 不返回指向静态数据的指针；
>- 所有的数据必须由函数的调用者提供；
>- 使用本地数据或者通过制作全局数据的本地副本来保护全局数据；
>- 如果必须访问全局变量，则利用互斥锁、信号量等来保护全局变量；
>- 不调用任何不可重入函数。

不可重入函数的特点：

>- 函数中使用了静态变量（local or non-local）；
>- 函数返回静态变量；
>- 函数调用不可重入函数；
>- 函数体内使用了静态的数据结构；
>- 函数体内调用了malloc()或者free()函数；
>- 函数体内调用了其他标准的I/O函数。

## 第十章 进程

Linux的进程结构一般由3部分组成：代码段、数据段和堆栈段。代码段用于存放程序代码的数据，如果有数个进程使用相同的程序可以共享一个代码段。数据段用于存放程序的全局变量、常量和静态变量。堆栈段中的栈用于函数调用，它存放着函数的参数，函数内部定义的局部变量。堆栈段还包括进程控制块（Process Control Block，PCB）。PCB处于进程核心堆栈的地步，不需要额外分配空间。PCB是进程存在的唯一标识，系统通过PCB感知进程的存在。PCB还包括创建进程、执行进程、退出进程以及改变进程的优先级等。

一般Linux下的C++程序的生成分为四个阶段：预编译，编译，汇编、链接。编译器经过前三个步骤把源程序文件转化为目标文件。如果程序有多个目标文
」或者程序使用了库函数，编译器还要将所有的的目标文件或所需的库链接起来，最后形成可执行的程序。当程序执行时，操作系统将可执行程序复制到内存中。

程序转化为进程一般需要下列步骤：

>- 内核将程序读入内存，为程序分配内存空间；
>- 内核为进程分配进城标志符PID和其他所需的资源；
>- 内核为进程保存PID以及相应的状态信息，把进程放到运行队列中等待执行。

同一个程序文件可以被加载多次称为不同的进程。进程和进程标志符之间一一对应。

### 进程的创建和结束

进程的创建有两种方式：一种是由操作系统创建，一种是由父进程创建。系统启动时，操作系统会创建系统进程，用于管理和分配系统资源。Linux允许任何一个用户进程创建一个子进程，创建成功后，子进程将存在于系统之中，并且独立于父进程。该子进程接收系统调度，可以得到分配的系统资源。系统也可以检测到子进程的存在，并赋予它与父进程同样的权利。

Linux系统下使用fork()函数创建一个子进程。fork()函数会从内核中为此进程分配一个新的进程标志符，分配进程空间，并将父进程空间中的内容复制到子进程的进程空间，包括父进程的数据段和堆栈段，并且和父进程共享代码段。父子进程都停留在fork()函数中，等待返回。因此fork()函数会返回两次，对于父进程返回子进程的PID，对于子进程返回0。子进程完全复制了父进程的地址空间的内容，包括堆栈段和数据断的内容。但是子进程没有复制代码段，而是和父进程共用代码段。因为父子进程可能执行不同的流程来改变堆栈段和数据段，因此需要分开存储，但是代码段是只读的，不存在被修改的问题，因此可以共享代码段来节省存储空间。

现在的Linux内核在实现fork函数时，往往在创建子进程时并未立即复制父进程的数据段和堆栈段，而是当子进程修改这些数据内容时复制操作才会发生，内核才会给子进程分配进程空间，将父进程的内容复制过来。这也是现代操作系统一个重要概念——“写时复制”的一个重要体验。

当一个进程需要退出时，需要调用退出函数。Linux环境下是用exit()函数退出进程，函数原型如下：

```cpp
#include <stdlib.h>
void exit(int status);
```

exit()函数的参数表示进程的退出状态，这个状态是一个整型，保存在全局变量¥?中。执行echo ¥?可以获得最近一个已结束进程的退出状态。Linux进程退出有正常退出和异常退出两种状态。

>- 正常退出：
>>- 在main()函数中执行return;
>>- 调用exit()函数；
>>- 调用_exit()函数。
>- 异常退出：
>>- 调用abort()函数；
>>- 进程收到某个信号，该信号使得进程终止。

不管哪一种退出方式，系统最终都会执行内核中的统一代码，这段代码用来关闭进程所有已打开的文件描述符，释放它所占用的内存和其他资源。

exit和return的区别：exit是一个函数，带有参数，exit执行完后把控制权交给系统。return是函数执行完后的返回，return执行完后把控制权交给调用函数。

exit和abort的区别：exit是正常终止进程。abort是异常终止进程。

exit()和_exit()的联系和区别：二者都是用来终止进程的，执行到该函数时，系统无条件地停止剩下所有操作，清除包括PCB在内的各种数据结构，并终止本进程的运行。前者舍命在stdlib.h中声明，后者在unistd.h中声明。exit中的参数为0表示正常终止，其他值表示执行过程中有错误发生。_exit()执行后立即返回给内核，而exit()则先执行一些清楚操作然后将控制权交给内核。调用_exit()时会先关闭所有的文件描述符，清理内存以及其他一些内核清理函数，但是不会刷新流(stdin, stdout, stderr,...)的数据。exit()是在_exit()函数之上的一个封装，会自动调用_exit()，并在调用之前刷新数据流。*最大的区别就在于exit()函数在调用exit系统之前要先检查文件的打开情况，吧文件缓冲区写回文件。*由于Linux的标准函数库中有一种被称为“缓冲I/O”的操作，其特征就是对应每一个打开的文件，在内存中都有一片缓冲区，读文件时连续读出若干条记录，在读可以从缓冲区读取；写文件时先写入缓冲区，缓冲区到一定数量后再写入文件。因此如果想保证数据的完整性一定要使用exit()。

### 僵尸进程

孤儿进程是父进程已退出，子进程未推出；僵尸进程是父进程未退出，而子进程已经退出。

孤儿进程是指父进程退出后，一个或者多个子进程仍在运行，则这些子进程成为孤儿进程。孤儿进程将被init进程(PID=1)所收养，并由init进程对它们完成状态收集工作。僵尸进程是指一个进程是用fork创建子进程，如果子进程意外退出，而父进程并未调用wait或者waitid获取子进程的状态信息，那么子进程的进程描述符依然保存在系统中，这些进程成为僵尸进程。当一个进程完成它的工作并终止之后，它的父进程应当调用wait()或者waitid()系统调用取得子进程的终止状态。父进程退出后，僵尸进程成为孤儿进程过继给init进程，init进程周期性调用wait系统调用来清除各个僵尸的子进程。

可以看出wait()函数可以回收子进程。进程一旦调用了wait函数，就立即阻塞自己，由wait自动分析当前进程的某个子进程是否已经退出，如果找到了已经变成僵尸进程的子进程，wait就会自动收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一整个子进程，则会一直阻塞直到有一个为止。

```cpp
// wait函数的头文件
#include <sys/types.h>
#include <sys/wait.h>
// 函数原型
pid_t wait(int *status);
```

wait函数暂停目前进程的执行，直到有信号来或者子进程结束。如果在调用wait时子进程已经结束，则wait函数会立即返回子进程的结束状态值。子进程的结束状态值会由参数status返回，子进程的进程识别码也会一并返回。如果不需要结束状态值，则参数status可以设置成NULL。如果执行成功则返回子进程识别码(PID)，如果有错误发生则返回-1，并将失败原因存在errno中。

WIFEXITED(status)用来表示子进程是否正常退出。返回非零值表示正常退出。

WEXITSTATUS(status)用来提取子进程的返回值，即exit(int *status)的 *status的值。

waitid函数时wait函数的封装，waitid只是多出了两个可由用户控制的参数pid和options，为编程提供灵活性。

```cpp
// wait函数的头文件
#include <sys/types.h>
#include <sys/wait.h>
// 函数原型
pid_t waitid(pid_t pid, int *status, int options);
```

waitid函数会暂时停止目前进程的执行，直到有信号来或者子进程结束。如果在调用waitid时子进程已经结束，则wait函数会立即返回子进程的结束状态值。子进程的结束状态值会由参数status返回，子进程的进程识别码也会一并返回。如果不需要结束状态值，则参数status可以设置成NULL。

参数PID为欲等待的子进程识别码。

>- pid<-1 等待进程识别码为PID绝对值的任何子进程
>- pid=-1 等待任何子进程，相当于wait
>- pid=0 等待进程识别码鱼目前进程相同的任何子进程
>- pid>0 等待任何子进程识别码为pid的子进程

options = WNOHANG 即使没有子进程退出也会立即返回，不会像wait那样一直等下去。options = WUNTRACED 子进程进入暂停则马上返回，但结束状态不予理会。Linux只支持这两个选项，可以用“|”把它们连接起来使用。如果不想使用可以设置为0。

waitid的返回值如下所述。

>- 如果正常返回，waitid返回收集到的子进程的进程ID；
>- 如果设置了WNOHANG，而调用中waitid发现没有已经退出的子进程可收集，则返回0；
>- 如果调用中出错，则返回-1，errno被设置为相应的值指示错误所在；
>- 当pid指示的子进程不存在或者进程存在但不是调用进程的子进程，waitid就会出错返回，errno设置为ECHILD。

### 守护进程

在Linux或者UNIX操作系统中在系统的引导的时候会开启很多服务，这些服务就叫做守护进程。

Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。守护进程的名称通常以d结尾，比如sshd、xinetd、crond等。

#### 创建守护进程

进程组: 每个进程也属于一个进程组。每个进程主都有一个进程组号，该号等于该进程组组长的PID号。一个进程只能为它自己或子进程设置进程组ID号。会话期：会话期(session)是一个或多个进程组的集合。

setsid()函数可以建立一个对话期。如果调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。此进程变成该对话期的首进程。此进程变成一个新进程组的组长进程。此进程没有控制终端，如果在调用setsid前，该进程有控制终端，那么与该终端的联系被解除。如果该进程是一个进程组的组长，此函数返回错误。为了保证这一点，我们先调用fork()然后exit()，此时只有子进程在运行。

编写守护进程的一般步骤步骤：

>1. 在父进程中执行fork并exit退出(子进程成为孤儿进程被init进程收养)
>2. 在子进程中调用setsid函数创建新的会话(让进程摆脱原会话的控制，摆脱原进程组的控制，摆脱原控制终端的控制)
>3. 在子进程中调用chdir函数，让根目录 ”/” 成为子进程的工作目录；
>4. 在子进程中调用umask函数，设置进程的umask为0；
>5. 在子进程中关闭任何不需要的文件描述符。

详细说明：

在后台运行：为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。

```cpp
if(pid=fork())
exit(0);       //是父进程，结束父进程，子进程继续
```

脱离控制终端，登录会话和进程组：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。控制终端，登录会话和进程组通常是从父进程继承下来的。调用setsid()使进程成为会话组长，目的就是要摆脱它们，使之不受它们的影响。

```cpp
setsid();
```

当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。

禁止进程重新打开控制终端：现在进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端。

```cpp
if(pid=fork())
exit(0);        //结束第一子进程，第二子进程继续（第二子进程不再是会话组长）
```

关闭打开的文件描述符：进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。

```cpp
for(i=0;i<MAXFILE;++i)
close(i);
```

改变当前工作目录：进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如/tmp

```cpp
chdir("/")
```

重设文件创建掩模：进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除。

```cpp
umask(0);
```

处理SIGCHLD信号：处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。

```cpp
signal(SIGCHLD,SIG_IGN);
```

这样，内核在子进程结束时不会产生僵尸进程。这一点与BSD4不同，BSD4下必须显式等待子进程结束才能释放僵尸进程。

## 第十一章 进程间通信

Linux常用的进程间通信方式：管道、消息队列、共享内存、信号量、套接字。前面四种主要用于同一台机器上的进程通信，套接字则主要用于不同及期间的网络通信。

### 管道

父子进程之间并不共享堆栈段和数据段，它们之间是通过管道进行通信的。管道是一种两者进程间进程单向通信的机制。因为管道传递数据具有单向行，又被称为半双工管道。

>- 数据只能由一个进程流向另一个进程，如果要进行双工通信需要建立两个管道；
>- 管道只能用于父子进程或者兄弟进程间通信，即只能用于具有亲缘关系的进程间通信；
>- 管道没有名字(无名管道)；
>- 管道的缓冲区大小受限制，传输的是无格式的字节流(需要管道输入和输出方事先约定数据格式)；

从本质上讲，管道也是一种文件，但又与一般的文件不同，可以克服使用文件进行通信的问题，这个文件只存在于内存中。通过管道通信的两个进程，一个向管道缓冲区的末尾写入数据，一个才能够管道缓冲区的头部读出数据。

```cpp
#include <unistd.h>

int pipe(int fd[2]);
```

一个进程在由pipe函数创建管道后，一般再使用fork建立一个子进程，从而实现父子进程间的通信。fd[0]为管道读端，fd[1]为管道写端。一般的文件I/O函数都可以用于管道，如close、read、write等。

还有一种管道成为有名管道(named pipe, or FIFO)，不同之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中，这样及时与FIFO的创建进程不存在血缘关系的进程，只要可以访问该路径，即能够彼此通过FIFO相互通信，因此通过FIFO不相关的进程也能够交换数据。

>- 可以使互不相关的两个进程间实现彼此通信；
>- 管道可以通过路径名来指出，并在文件系统中可见，当作普通文件一样进行读写操作；
>- FIFO严格遵循先进先出原则，对管道以及FIFO文件的读操作总是从开始处返回数据，写操作则是把数据写到末尾。

```cpp
#include <sys/types.h>
#include <sys/stat.h>

int mkfifo(const char* pathname, moode_t mode);
```

mkfifo函数的第一个参数是普通的路径名，也是创建后FIFO的名字，第二个参数与打开普通文件的open函数的mode参数相同。如果mkfifo的第一个参数是已经存在的路径名，返回EEXIST错误。一般的文件I/O函数都可以用于管道，如close、read、write等。

### 消息队列

消息队列用于运行于同一台机器上的进程通信，它和管道很相似，是一个在系统内核中用来保存消息的队列，在系统内核中一消息链表的形式出现。消息链表的结构用msg声明。

```cpp
// 创建新消息队列或哦着取得已存在的消息队列
// key可以认为是一个端口号，也可以由ftok生成
// msgflg如果等于IPC_EREAT，若没有该队列则创建一个并返回新的标志符，如已存在则返回原标识符
// msgflg如果等于IPC_ECXL，若没有该队列则返回-1，若已存在则返回0
int msgget(key_t key, int msgflg);
// 向队列读/写消息
// msgid是消息队列的标识码
// msgp是指向消息缓冲区的指针。此位置用来暂存发送和接收的消息们是一个用户可定义的通用结构
// msgsz是指消息的大小，msgtyp是指从消息队列读取的消息形态。如果值为0则表示队列中所有消息都会被读取
// msgflg用来指示核心程序在队列没有数据的情况下应采取的行动
size_t msgrcv(int msgid, void* msgp, size_t msgsz, long msgtyp, int msgflg);
int msgsnd(int msgid, const void* msgp, size_t msgsz, int msgflg);
// 设置消息队列的属性
// cmd操作有三种：IPC_STAT（获取消息队列对应的msgid_ds数据结构，保存到buf指定的地址空间）IPC_SET（设置消息队列属性，要设置的属性在buf中）IPC_RMID（用来从内核中删除msgid标识的消息队列）
int msgctl(int msgid, int cmd, struct msgid_ds* buf);
```

消息队列和有名管道比较相似，可以在不想关的进程间通信，通过发送和接收的方式来传递数据。有名管道使用write和read发送和接收数据，消息队列是用msgsnd和msgrcv来发送和接收数据，而且二者对每个数据都有一个最大长度限制。

消息队列的优势在于：

>- 消息队列可以独立于发送进程和接收进程而存在，从而消除了在同步有名管道的打开和关闭时可能产生的困难；
>- 可以通过发送消息以避免有名管道的同步和阻塞问题，而不需要由进程自己来提供同步方法；
>- 接收程序可以通过消息类型有选择地接收数据，而不是默认地接收。

### 共享内存

共享内存允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据库的一种非常有效的方式。不同的进程之间共享的内存通常安排在同一段物理内存中。使用共享内存进行进程间通信非常方便，接口函数也非常简单，数据的共享使得进程间的数据不用传送，而是直接访问内存，从而加快了程序的效率。此外也不需要无名管道那样对通信的双方由亲缘关系的要求。不过共享内存并没有提供同步机制，需要其他机制来同步对共享内存的访问。

```cpp
#include <sys/shm.h>
// 创建共享内存
int shmget(key_t key, int size, int flag);
// 将共享内存连接到自身的地址空间
void* shmat(int shmid, void* addr, int flag);
// 停用共享内存，将共享内存从当前进程中分离，并不是删除
int shmdt(const void* shmaddr);
```

### 信号量

用于多线程同步的信号量是POSIX信号量，进程间间通信需要的信号量则是SYSTEM V信号量。本质上两种都是用户态进程可以使用的信号量。共享内存是进程间通信最快的方式，但自身的同步问题无法解决，但是用信号量可以解决这个问题。

```cpp
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
// 创建和打开信号量
int semget(key_t key, int nsems, int semflg);
// 修改信号量的值
int semop(int semid, struct sembuf* sops, unsigned nsops);
// 用来直接控制信号量信息
int semctl(in semid, int semnum, int cmd, ...);
```

### IPCS

ipcs命令用于报告消息系统的消息队列，信号量和共享内存等。

>- ipcs -a 用于列出本用户所有相关的ipcs参数。
>- ipcs -q 用于列出进程中的消息队列。
>- ipcs -s 用于列出所有的信号量。
>- ipcs -m 用于列出所有的共享内存信息。
>- ipcs -l 用于列出系统的限额。
>- ipcs -t 用于列出最后的访问时间。
>- ipcs -u用于列出当前的使用情况。