# 后台开发读书笔记

## 第六章 TCP协议

TCP/IP分层模型：应用层，传输层，网间层，网络接口层。

应用层对应于OSI七层参考模型中的应用层和表示层。常见的应用层协议有Finger、Whois，FTP，Gopher，HTTP，Telent，SMTP，IRC，NNTP等。传输层对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议提供可靠的数据流运输服务，UDP协议提供不可靠的用户数据报服务。网间层对应于OSI七层参考模型的网络层。本层包含IP协议，RIP协议，负责数据的包装、寻址和路由。同时还包含ICMP用来提供网络诊断信息。网络接口层包括用于协作IP数据在已有网路介质上传输的协议。

### TCP头部的格式

![TCPHead](../Resource/TCPHead.png)

>- 源端口 source port 16bit 用来告知主机该报文段是来自哪里。进行TCP通讯时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号；
>- 目的端口 destination port 16bit 用来告诉远程主机报文段交付给谁；
>- 序号 sequence number TCP 是面向字节流的，在一个TCP连接中传输的字节流中的每个字节都按照顺序编号，用来解决乱序问题。4个字节可以表示的数值范围：[0, 2^32]，一共 2^32 (4294967296) 个序号。序号增加到最大值的时候，下一个序号又回到了0。也就是说TCP协议可对4GB的数据进行编号，在一般情况下可保证当序号重复使用时，旧序号的数据早已经通过网络到达终点或者丢失。主机A和主机B进行通信，A发送给B的第一个TCP报文段中，序号值会被初始化为某个随机的ISN（Initial Sequence Number）。在该传输方向上后续的TCP报文中的序号值将被系统设置成ISN+该报文段所携带的第一个字节在整个字节流中的偏移；
>- 确认号 acknowledgment number 用作对另一方发来的TCP报文段的响应，用来解决丢包问题。其值是收到的TCP报文段序号值+1；
>- 数据偏移 offset 占4比特，表示数据开始的地方离TCP段的起始处有多远。实际上就是TCP段首部的长度。由于首部长度不固定，因此数据偏移字段是必要的。数据偏移以32位为长度单位，也就是4个字节，因此TCP首部的最大长度是60个字节。即偏移最大为15个长度单位=15x32位 = 15x4字节；
>- 保留 reserved；
>- 标志位 tcp flags，包括URG（紧急指针是否有效，告诉系统此报文段中有紧急数据，应尽快传送，而不要按原来的排队顺序来传送。 URG要与首部中的 紧急指针 字段配合使用），ACK（确认号是否有。TCP 规定，在连接建立后所有传送的报文段都必须把ACK设置为 1。），PSH（提示接收端应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付），RST（表示对方要求重新建立连接，复位报文段），SYN（表示建立一个连接，同步报文段），FIN（表示通知对方本段要关闭连接，结束报文段）；
>- 窗口大小 window size 用于流量控制，告诉对方本段的TCP接收缓冲区还能容纳多少字节，让对方控制发送数据的速率；
>- 检验和 checksum，接收端对TCP报文执行CRC校验，不仅包括头部，还包括数据部分；
>- 紧急指针 urgent pointer 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 当URG=1时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。 因此，紧急指针指出了紧急数据的末尾在报文段中的位置；
>- 选项 tcp option。

### TCP报文大小

TCP提供的是一种面向连接的，可靠的字节流服务，TCP提供可靠性的一种重要的方式就是MSS。通过MSS，应用数据被分割成TCP认为最适合发送的数据块，由TCP传递给IP的信息单位称为报文段或段(segment)。代表一个TCP socket的结构体struct tcp_sock中有多个成员用于确定应用数据被分割成最大为多大的数据块较为合适(最大报文段长度MSS)。与最大报文段长度最为相关的一个参数是网络设备接口的MTU，以太网的MTU是1500Byte，基本IP首部长度为20Byte，TCP首部最小是20Byte，所以MSS的值可达1460Byte(MSS不包括协议首部，只包含应用数据)。UDP首部是8Byte，所以UDP的负载最大为1472Byte。

在建立连接的时候，通信双方会相互确认对方的最大报文段。对于一个以太网一般可以到1460Byte，对于非本地的IP，MSS可能只有536Byte。而且中间传输网络的MSS更小的话，这个值会更小。

### 保护消息边界和流

保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包。而面向流则是指无保护消息保护边界的，如果发送端连续发送数据，接收端有可能在一次接收动作中，会接收两个或者更多的数据包。

例如连续发送三个数据包，大小分别是2k，4k ，8k,这三个数据包，都已经到达了接收端的网络堆栈中，如果使用UDP协议，不管使用多大的接收缓冲区去接收数据，必须有三次接收动作，才能够把所有的数据包接收完；而使用TCP协议，只要把接收的缓冲区大小设置在14k以上，就能够一次把所有的数据包接收下来，只需要有一次接收动作。

这就是因为UDP协议的保护消息边界使得每一个消息都是独立的。而流传输却把数据当作一串数据流，它不认为数据是一个一个的消息。所以有很多人在使用tcp协议通讯的时候，并不清楚tcp是基于流的传输，当连续发送数据且使用的缓冲区足够大时，有可能会一次接收到两个甚至更多的数据包，而很多人往往会忽视这一点，只解析检查了第一个数据包，而已经接收的其他数据包却被忽略了。

### TCP 与 UDP 的比较

TCP为了保证可靠传输，尽量减少额外开销（每次发包都要验证），因此采用了流式传输，面向流的传输，相对于面向消息的传输，可以减少发送包的数量，从而减少了额外开销。但对于数据传输频繁的程序来讲，使用TCP可能会容易粘包。当然，对接收端的程序来讲，如果机器负荷很重，也会在接收缓冲里粘包。这样就需要接收端额外拆包，增加了工作量。因此TCP特别适合的是数据要求可靠传输，但是不需要太频繁传输的场合（两次操作间隔100ms，具体是由TCP等待发送间隔决定的，取决于内核中的socket的写法）。

UDP，由于面向的是消息传输，它把所有接收到的消息都挂接到缓冲区的接受队列中，因此它对于数据的提取分离就更加方便，但它没有粘包机制。因此，当发送数据量较小的时候，就会发生数据包有效载荷较小的情况，也会增加多次发送的系统发送开销（系统调用，写硬件等）和接收开销。因此，应该最好设置一个比较合适的数据包的包长，来进行UDP数据的发送。（UDP最大载荷为1472，因此最好能每次传输接近这个数的数据量，这特别适合于视频，音频等大块数据的发送，同时通过减少握手来保证流媒体的实时性）

### 拆包与粘包问题

在socket网络程序中，TCP和UDP分别是面向连接和非面向连接的。因此TCP的socket编程，收发两端（客户端和服务器端）都要有成对的socket。发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据合并成一个大的数据块，然后进行封包。这样接收端就难以分辨出来了，必须提供科学的拆包机制。

UDP不会出现粘包问题，因为它有消息边界。UDP不会使用块的合并优化算法，接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息）。这样对于接收端来说就容易进行区分处理。

发生TCP粘包或拆包有很多原因，现列出常见的几点。

>- 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。
>- 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。
>- 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。
>- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。不是所有的粘包现象都需要处理，若传输的数据为不带结构的连续流数据（如文件传输），则不必把粘连的包分开（简称分包）。但在实际工程应用中，传输的数据一般为带结构的数据，这时就需要做分包处理。在处理定长结构数据的粘包问题时，分包算法比较简单；在处理不定长结构数据的粘包问题时，分包算法就比较复杂。特别是粘在一起的包有不完整的包的粘包情况，由于一包数据内容被分在了两个连续的接收包中，处理起来难度较大。实际工程应用中应尽量避免出现粘包现象。

>- 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度。
>- 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
>- 可以在数据包之间设置边界，如添加特殊符号，接收端通过这个边界就可以将不同的数据包拆分开。

### TCP状态流转

![TCPHandShake](../Resource/TCPHandShake.jpg)

三次握手的原因：两个SYN报文段是必须的，通信的双方要互相确认信息，比如MSS的长度。最后一次Client发送给Server的确认是为了防止已失效的连接请求报文突然又传送到了Server，而产生错误。已失效的连接请求报文段是这样产生的：Client发送了一个请求建立连接报文段，然后Client不再需要建立连接。而这个失效的连接请求报文段到达Server后，Server以为建立了连接而消耗了资源等待Client发送数据。而采用三次握手，Server要发送SYN+ACK的报文段，并得到Client的确认后才会进入连接建立的状态。在刚才的情况下，Client不会向Server的确认发出确认。Server由于收不到确认，就知道Client并没有要求建立连接。

![TCPWaveShake](../Resource/TCPWaveShake.jpg)

四次挥手的原因：TCP是全双工的，所以双方都要FIN和ACK。只不过一方是被动的，所以看起来称为所谓的四次挥手。如果两边同时断开连接，那就会进入到CLOSING状态，然后就会到达TIME_WAIT状态。

下面来看看这个看似有点多余的TIME_WAIT状态。主动方最后回应一个ACK，主要作用是保证TCP协议的全双工连接能够可靠关闭和保证这次连接的重复数据段从网络中消失。

先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。

再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。

![TCPStatus](../Resource/TCPStatus.jpg)

### TCP超时重传

在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。影响超时重传机制协议效率的一个关键参数是重传超时时间（RTO，Retransmission TimeOut）。RTO的值被设置过大过小都会对协议造成不利影响。RTO设长了，重发就慢，没有效率，性能差。RTO设短了，重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。RTO的设置和RTT有关。连接往返时间（RTT，Round Trip Time），指发送端从发送 TCP 包开始到接收它的立即响应所消耗的时间。

### TCP滑动窗口

滑动窗口提供TCP的可靠性和流控特性。

![Window](../Resource/TCPSendW.jpg)

![Window](../Resource/TCPReceiveW.jpg)

TCP的滑动窗口的可靠性也是建立在 “确认重传” 基础上的。发送窗口只有收到对端对于本段发送窗口内字节的ACK确认，才会移动发送窗口的左边界。接收端可以根据自己的状况通告窗口大小，从而控制发送端的接收，进行流量控制。

发送方窗口的上限值 = Min [rwnd, cwnd]
当rwnd < cwnd 时，是接收方的接收能力限制发送方窗口的最大值。
当cwnd < rwnd 时，则是网络的拥塞限制发送方窗口的最大值。

### TCP拥塞控制

拥塞控制是一个全局性的过程； 流量控制是点对点通信量的控制。TCP拥塞控制4个核心算法：慢开始（slow start）、拥塞避免（Congestion Avoidance）、快速重传（fast retransmit）、快速回复（fast recovery）。拥塞窗口（cwnd，congestion window），其大小取决于网络的拥塞程度，并且动态地在变化。

慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。

>- 当 cwnd < ssthresh 时，使用慢开始算法。
>- 当 cwnd > ssthresh 时，改用拥塞避免算法。
>- 当 cwnd = ssthresh 时，慢开始与拥塞避免算法任意。

拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送发的拥塞窗口cwnd加1，而不是加倍。无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为 1，执行慢开始算法。

![Window](../Resource/TCPCC.png)

>- TCP 连接初始化，将拥塞窗口设置为1；
>- 执行慢开始算法，cwnd按指数规律增长，直到cwnd=ssthresh时，开始执行拥塞避免算法，cwnd按线性规律增长；
>- 当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwnd重新设置为1，重新开始慢开始算法。

### 快重传和快恢复

快速重传 (Fast retransmit) 要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到 3 个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计数器时间到期。

在当发送方连续收到三个重复确认，就执行 “乘法减小” 算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。快速恢复 (Fast Recovery)则不执行慢开始算法。由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

### TCP网络编程API

网络中的进程之间如何通信？首先解决的问题是如何标识一个进程。网络层的IP地址可以标识网络中的主机，传输层的“协议+端口号”可以唯一标识主机中的应用程序（进程）。这样利用三元组（IP地址，协议，PORT端口号）就可以标识网络进程。

Socket起源于UNIX。UNIX/Linux基本哲学之一就是一切皆文件，都可以用“open-write/read-close”模式来操作。Socket就是一种特殊的文件，一些Socket函数就是对其进行读写，打开，关闭的操作。

![TCPSocket](../Resource/TCPSocket.png)

服务器Socket接收到客户端Socket请求后被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候Socket进入阻塞状态，即accept()方法一直到客户端返回连接信息后才返回，开始接收下一客户端的连接请求。

#### Socket函数

```cpp
int socket(int domain, int type, int protocal);
```

domain指定要创建的套接字的协议簇地址类型：AF_INET（使用ipv4地址与端口号作为地址），AF_INET6，AF_LOCAL（又称AF_UNIX，Unix的Socket，使用绝对路径作为地址），AF_ROUTE。
type指定套接字类型：SOCK_STREAM（提供面向连接的稳定数据传输），SOCK_DGRAM（使用不连续不可靠的数据报连接），SOCK_RAW，SOCK_PACKET，SOCK_SEQPACKET。
protocol指定协议类型：IPPROTO_TCP，IPPROTO_UDP，IPPROTO_SCTP，IPPROTO_TIPC。通常设置为0，表示使用默认协议。

当调用socket创建一个Socket时，返回的socket描述字存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要赋予一个地址必须调用bind()函数，否则系统在调用connect()，listen()会自动随机分配一个端口。

如果函数执行发生异常，将返回值为INVALID_SOCKET（linux下返回-1）的错误码，程序需要对这个返回值进行检查以保证程序的正常运行。返回的套接字描述符是一个整型类型的值。每个进程的进程空间里都有一个套接字描述符表，该表中存放着套接字描述符和套接字数据结构的对应关系。该表中有一个字段存放新创建的套接字的描述符，另一个字段存放套接字数据结构的地址。每个进程在自己的进程空间中都有一个套接字描述符表，但是套接字数据结构存放在操作系统的内核缓冲里。

```cpp
int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
```

bind()函数把一个地址族的特定地址赋给socket。例如对应的AF_INET，AF_INET6就是把一个ipv4或者ipv6地址和端口号组合赋给socket。函数执行成功返回0，否则返回SOCKET_ERROR。

sockfd为socket描述子，是通过socket函数创建来唯一标识一个Socket的。bind函数给这个描述字绑定一个名字。

addr是一个指针，指向要绑定的sockfd的协议地址。这个地址结构根据创建socket时的地址协议族的不同而不同。

```cpp
// ipv4
struct sockaddr_in {
    sa_family_t    sin_family; // address family: AF_INET
    in_port_t      sin_port;   // port in network byte order
    struct in_addr sinn_addr;  // internet address
}

struct in_addr {
    uint32_t s_addr;           // address in network byte order
}
```

addrlen对应的是地址的长度。

服务器启动时一般会绑定一个众所周知的地址，用于提供服务，所以一般会在调用listen前调用bind()；客户端则不用指定，在connect()时随机生成一个。

```cpp
int listen(int sockfd, int backlog);
int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
```

listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应的socket可以排队的最大连接个数。socket()函数创建的Socket默认是一个主动类型的，listen函数将其设置为被动类型的。

connect函数的第一个参数为客户端的socket描述字，第二个参数为服务器的socket地址，第三个参数为socket地址的长度。客户端调用connect函数和TCP服务器建立连接。

```cpp
int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);
```

TCP服务器监听到请求后会调用accept函数接收请求，建立连接后就可以开始网络I/O操作。accept函数的第一个参数为服务器的socket描述字，第二个参数是指针，用于返回客户端的协议地址，第三个参数是指针，用于返回协议地址的长度。如果accept成功，那么其返回值是内核自动生成的一个全新的描述字，代表于客户端的TCP连接。一个服务器通常只创建一个监听socket描述字，它在服务器的生命周期一直存在。内核为每个由服务器进程接收的客户端创建一个已连接的socket描述字，当服务器完成了对某个客户端的服务，相应的socket描述字就被关闭。

```cpp
ssize_t read(int fd, void* buf, size_t count);
```

read函数负责从fd中读取内容，读取成功返回实际所读的字节数，如果返回值是0表示已经读到文件结束，小于0表示出现了错误。如果错误为EINTR说明是由中断引起的，如果是ECONNREST表示网络连接除了问题。三个参数分别是socket描述字，缓冲区和缓冲区长度。

```cpp
ssize_t write(int fd, const void* buf, size_t count);
```

write函数负责向buf中写入内容。写入成功返回写入的字节数。失败返回-1，并设置errno变量。返回值大于0表示写了部分或者全部数据，返回值小于0表示出现了错误。如果错误为EINTR说明是由中断引起的，如果为EPIPE表示网络连接出现了问题（对方关闭了连接）。三个参数分别是socket描述字，缓冲区和缓冲区长度。

其他的网络I/O操作还有以下几组：recv()/send() readv()/writev() recvmsg()/sendmsg() recvfrom()/sendto()。

```cpp
int close(int fd);
```

close一个TCP socket的默认行为是，会把该socket标记为已关闭。然后立即返回到回调进程。close只是使相应的socket描述字的引用计数器-1，只有当引用计数为0时才会出发TCP客服端向服务器发送终止连接的请求。

### TCP协议选项

TCP头部的固定长度为20Byte，选项部分最长为60Byte（数据偏移4bit，取最大1111，偏移量的单位是32bit，即4Byte）。TCP选项部分实际应用有以下几种。

>- SO_REUSEADDR 一般来说一个端口被释放后需要两分钟左右的等待（TIME_WAIT）才能再次使用，使用该选项可以是端口释放后立即被使用。server程序应该在调用bind()之前设置SO_REUSEADDR套接字选项。
>- TCP_NODELAY/TCP_CHORK 为了解决糊涂窗口症候群（有效荷载利用率低）的问题提出了Nagle算法。如果发送端要多次发送包含少量字符的数据包，则发送端会先将第一个小包发出去，而将后面到达的少量字符数据都缓存起来而不立即发送，直到接收端对前一个数据包报文段的ACK确认位置，或者当前字符属于紧急数据，或者积攒到一定数量的数据等多种情况下才将其组成一个较大的数据包发送出去。Nagle是默认开启的，但是并不适用于所有场景。TCP_NODELAY/TCP_CHORK都禁用了该算法。TCP_NODELAY不会讲小包拼接成大包发送而是直接发送小包；在传送大量数据的时候可以设置TCP_CHORK，这样会尽量在每次发送最大的数据量。设置TCP_CHORK后会有200ms的阻塞，当阻塞时间过后数据会自动发送。
>- SO_LINGER 默认close立即返回，但是当发送缓冲区中还有一部分数据的时候系统会尝试将数据发送给对端。通过设置SO_LINGER可以改变close的行为，可以采用默认情形；或者close不被阻塞立即执行，丢弃socket发送缓冲区的数据并向对端发送RST报文来强制关闭（这种非正常呢的四次握手方式结束TCP连接，TCP连接不会进入TIME_WAIT状态）；或者close调用阻塞进程，直到所有所有数据发送完毕或超时。
>- TCP_DEFFER_ACCEPT 当接收到第一个数据后才创建连接，对于像HTTP等非交互式服务器很有意义，可以防御空链接攻击。
>- SO_KEEPALIVE 用于保持连接，检测对方主机是否崩溃，避免永远阻塞于TCP连接的输入。
>- SO_SNDTIMEO/SO_RCVTIMEO 分别设置socket的发送和接收超时时间。接收超时会影响read，readv，recv，revcfrom，recvmsg的状态，发送超时会影响write，writev，send，sendto，sendmsg的状态。
>- SO_RECVBUF/SO_SNDBUF 分别设置发送和接收缓冲区的大小。TCP对发送但未收到确认的数据保留一个副本，直到被确认为止。

### HTTP协议

#### web始祖HTTP

全称：超文本传输协议 (HyperText Transfer Protocol) 伴随着计算机网络和浏览器的诞生，HTTP1.0 也随之而来，处于计算机网络中的应用层，HTTP是建立在TCP协议之上，所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如tcp建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。

HTTP的请求和回应报文都分为报文头，0和或者多喝请求头，空行和可选的消息体四个部分。HTTP协议是基于行的协议，每一行都以\r\n作为分隔符。HTTP/1.1协议定义了9中方法（或者称动作）来表示Request-URI指定资源的不同操作方式：OPTIONS，HEAD，GET，POST，PUT，DELETE，TRACE，CONNECT，PATHC。

#### HTTP的基本优化

影响一个HTTP网络请求的因素主要有两个：带宽和延迟。如果说还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，不再会担心由带宽而影响网速，那么就只剩下延迟了。

>- 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有4个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。
>- DNS查询（DNS Lookup）：浏览器需要知道目标服务器的IP才能建立连接。将域名解析为IP的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。
>- 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带HTTP请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。

#### HTTP1.0 和 HTTP1.1

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：

>- 缓存处理，在HTTP1.0中主要使用header里的`If-Modified-Since` `Expires`来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如`Entity tag` `If-Unmodified-Since` `If-Match` `If-None-Match`等更多可供选择的缓存头来控制缓存策略。
>- 带宽优化及网络连接的使用，HTTP1.0 中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
>- 错误通知的管理，在 HTTP1.1 中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
>- Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
>- 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。以下是常见的 HTTP1.0：

![HTTP1&1.0](../Resource/HTTP1&1.0.png)

上面提到过的，HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出。HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。HTTP1.x 在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量。虽然 HTTP1.x 支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务 (例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。

#### HTTPS 应声而出

为了解决以上问题，网景在1994年创建了 HTTPS，并应用在网景导航者浏览器中。 最初，HTTPS是与SSL一起使用的；在SSL逐渐演变到TLS时（其实两个是一个东西，只是名字不同而已），最新的HTTPS也由在2000年五月公布的RFC 2818正式确定下来。HTTPS是安全版的HTTP，并且由于当今时代对安全性要求更高，chrome和firefox都大力支持网站使用HTTPS，Apple也在ios 10系统中强制app使用HTTPS来传输数据。  

HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。HTTP协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在 TCP 之上，所有传输的内容都经过加密的。HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

![HTTP&HTTPS](../Resource/HTTP&HTTPS.png)

如果一个网站要全站由HTTP替换成HTTPS，可能需要关注以下几点：安装CA证书，一般的证书都是需要收费的。在购买证书之后，在证书提供的网站上配置自己的域名，将证书下载下来之后，配置自己的web服务器，同时进行代码改造。HTTPS降低用户访问速度。由于SSL握手，HTTPS对速度会有一定程度的降低，但是只要经过合理优化和部署，HTTPS对速度的影响完全可以接受。在很多场景下，HTTPS速度完全不逊于HTTP，如果使用SPDY，HTTPS的速度甚至还要比HTTP快。相对于HTTPS降低访问速度，其实更需要关心的是服务器端的CPU压力，HTTPS中大量的密钥算法计算，会消耗大量的CPU资源，只有足够的优化，HTTPS的机器成本才不会明显增加。

2012年google提出了SPDY的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，主要解决：

>- 降低延迟，针对HTTP高延迟的问题，SPDY采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。
>- 请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
>- header压缩。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。
>- 基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。
>- 服务端推送（server push），采用了SPDY的网页，例如网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY 构成图：

![HTTPSPDY](../Resource/HTTPSPDY.png)

#### HTTP2.0 的前世今生

HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是HTTP2.0跟SPDY仍有不同的地方，主要是以下两点：

>- HTTP2.0支持明文HTTP传输，而SPDY强制使用HTTPS
>- HTTP2.0消息头的压缩算法采用HPACK，而非SPDY采用的DEFLATE

#### HTTP2.0 的新特性

>- 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
>- 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面。

![HTTP2MP](../Resource/HTTP2MP.png)

header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。服务端推送（server push），同SPDY一样，HTTP2.0 也具有server push功能。
关于 HTTP2 和 HTTP1.x 的区别大致可以看下图：

![HTTP1.1&2.0](../Resource/HTTP1.1&2.0.png)

#### HTTP2.0 的升级改造

HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于TLS部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。当网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考NGINX白皮书。使用了HTTP2.0那么，原本的 HTTP1.x 怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。

#### HTTP状态码

>- 1XX系列：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。
>- 2XX系列：成功。代表请求已成功被服务器接收、理解、并接受。
>- 3XX系列：重定向。代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。
>- 4XX系列：客户端错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。
>- 5xx系列：服务器端错误。服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。

100 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。

101 服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。

102 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。

200 请求已成功，请求所希望的响应头或数据体将随此响应返回。
201 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。

202 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。

203 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。

204 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。

205 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。

206 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。响应必须包含如下的头部域：Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。

207 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。

300 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。

301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。

302 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。

303 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。

304 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。该响应必须包含以下的头信息：Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。ETag 和/或 Content-Location，假如同样的请求本应返回200响应。Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。

305 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。

306 在最新版的规范中，306状态码已经不再被使用。

307 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。

400 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。

401 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。

402 该状态码是为了将来可能的需求而预留的。

403 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。

404 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。

405 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。

406 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。

407 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。

408 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。

409 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。

410 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。

411 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。

412 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。

413 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。

414 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。没有此类漏洞的服务器，应当返回414状态码。

415 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。

416 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。

417 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。

421 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。

422 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。

422 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）

424 由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）

425 在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。

426 客户端应当切换到TLS/1.0。（RFC 2817）

449 由微软扩展，代表请求应当在执行完适当的操作后进行重试。

500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。

501 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。

502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。

503 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。

504 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。注意：某些代理服务器在DNS查询超时时会返回400或者500错误。

505 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。

506 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。

507 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)

509 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。

510 获取资源所需要的策略并没有没满足。（RFC 2774）

### 网络字节序与主机序

不同的CPU有不同的字节序类型，字节序类型是指整数在内存中保存的顺序，称为主机序。Little Endian将低序字节存储在起始位置，Big Endian将高序字节存储在起始位置。比如数字0x12345678，采用Big Endian为 （低地址）12|34|56|78（高地址），采用Little Endian为（低地址）78|56|34|12（高地址）。

C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而JAVA编写的程序则唯一采用big endian方式来存储数据。试想，如果你用C/C++语言在x86平台下编写的程序跟别人的JAVA程序互通时会产生什么结果？就拿上面的0x12345678来说，你的程序传递给别人的一个数据，将指向0x12345678的指针传给了JAVA程序，由于JAVA采取big endian方式存储数据，很自然的它会将你的数据翻译为0x78563412。因此，在你的C程序传给JAVA程序之前有必要进行字节序的转换工作。

![BigEndian](../Resource/Big-Endian.png)

![LittleEndian](../Resource/Little-Endian.png)

所有网络协议也都是采用big endian的方式来传输数据的。所以有时我们也会把big endian方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。