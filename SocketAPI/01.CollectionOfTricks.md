
# Collection of Tricks

## socket编程

使用htonl/htons/ntohl/ntohs时并不需要主机字节序和网络字节序的真实值（大端or小端），只需要调用适当的函数在其中转换。使用socket API需要网络字节序，使用系统输入输出则需要主机字节序。

## EINTER错误

表示系统调用被一个捕获的信号中断。在socket的read()/write()被中断后应该继续调用read()/write()。

## errno

Linux 中系统调用的错误都存储于 errno中，errno由操作系统维护，存储就近发生的错误，即下一次的错误码会覆盖掉上一次的错误。

只有当系统调用或者调用 lib 函数时出错，才会置位errno！

```cpp
// 打印错误信息 perror:打印系统错误信息
#include <stdio.h>

void perror(const char* s); // s为自定义提示信息，s为空直接输出错误信息，否则在s内容后加":"后输出错误信息
```

```cpp
// 字符串显示错误信息 strerror:将错误信息以字符串形式返回；
#include <string.h>  

auto str = char *strerror(int errnum); // 返回值为错误信息的字符串
```

## socket bind()

无论是网络字节序还是主机字节序，INADRR_ANY的值（0）都是一样的，因此无需htonl的转换，但是其他在头文件中定义的INADDR_XX常值都是按照主机字节序定义的，因此需要转换。

```cpp
struct sockaddr_int serveraddr;
serveraddr.sin_addr.s_addr = htonl(INADDR_XX);
```

如果没有指定端口号，由内核随机选择临时端口号，那么bind()后无法直接获取端口号，需要使用getsockname()函数来返回协议地址。getsockname()函数用于获取一个套接字的名字。它用于一个已捆绑或已连接套接字s，本地地址将被返回。本调用特别适用于如下情况：未调用bind()就调用了connect()，这时唯有getsockname()调用可以获知系统内定的本地地址。在返回时，namelen参数包含了名字的实际字节数。

``` cpp
#include <sys/socket.h>

int getsockname(int sockfd, struct sockaddr* localaddr,socklen_t *addrlen); // 若成功则为0，失败则为-1

// ... 创建socket sockfd...bind()sockfd

struct sockaddr_in myAddr;
bzero(&myAddr, sizeof(myAddr));
int len = sizeof(myAddr);

int ret = getsockname(sockfd, (struct sockaddr*)&myAddr, (soclen_t*)&len); // myAddr中存储了bind()后的sockfd地址信息，转换为主机字节序后可以打印。
cout<<"Current Socket IP:"<<inet_ntoa(myAddr.sin_addr)<<":"<<ntohs(myAddr.sin_port)<<endl;
```

类似的函数还有getpeername()，返回与某个套接字关联的外地协议地址即得到对方的地址。

``` cpp
#include <sys/socket.h>

int getpeername(int sockfd,struct sockaddr* peeraddr,socklen_t *addrlen);// 若成功则为0，失败则为-1
```
