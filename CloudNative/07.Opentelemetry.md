# opentelemetry-cpp v1.2.0

## context

### propagation

#### text_map_propagator.h & TextMapCarrier + TextMapPropagator Interface

```cpp
namespace context {
namespace propagation {

class TextMapCarrier {
public:
  // returns the value associated with the passed key.
  virtual nostd::string_view Get(nostd::string_view key) const noexcept = 0;
  // stores the key-value pair.
  virtual void Set(nostd::string_view key, nostd::string_view value) noexcept = 0;
  /* list of all the keys in the carrier.
   By default, it returns true without invoking callback */
  virtual bool Keys(nostd::function_ref<bool(nostd::string_view)> callback) const noexcept;
  // ...
};

class TextMapPropagator
{
public:
  // Returns the context that is stored in the carrier with the TextMapCarrier as extractor.
  virtual context::Context Extract(const TextMapCarrier &carrier,
                                   context::Context &context) noexcept = 0;
  // Sets the context for carrier with self defined rules.
  virtual void Inject(TextMapCarrier &carrier, const context::Context &context) noexcept = 0;
  // Gets the fields set in the carrier by the `inject` method
  virtual bool Fields(nostd::function_ref<bool(nostd::string_view)> callback) const noexcept = 0;
  // ...
};
}
}
```

## trace api

按照协议提供 API，span/tracer 两个纯虚类，提供了 no-op 实现（示例）。

traceprovider 创建 tracer (单例)，tracer 创建 span（线程存储）。

### canonical_code.h

```cpp
namespace trace {
enum class CanonicalCode : uint8_t {
    // 通过 enum class 方式定义 [0, 16] 错误码
};
}
```

### span_id.h

```cpp
// 定义了 spanId 的具体实现 8 字节数组
// 序列化时调用 ToLowerBase16(二进制串联每四个bit转成一个字符，数据膨胀一倍) 方法
// eg: 6f 49  3d a4  75 c8  96 0d （base16编码后）
//     1  2   3  4   5  6   7  8   共 8 字节
namespace trace {
class SpanId final{
public:
  // The size in bytes of the SpanId.
  static constexpr int kSize = 8; // 定义 spanId 为 8 字节
  // Populates the buffer with the lowercase base16 representation of the ID.
  void ToLowerBase16(nostd::span<char, 2 * kSize> buffer) const noexcept;
  // Returns a nostd::span of the ID. 即 char[8]
  nostd::span<const uint8_t, kSize> Id() const noexcept;
  // Returns false if the SpanId is all zeros.
  bool IsValid() const noexcept;
  // Copies the opaque SpanId data to dest.
  void CopyBytesTo(nostd::span<uint8_t, kSize> dest) const noexcept;
  // ...
private:
  uint8_t rep_[kSize];
};
}
```

### trace_id.h

```cpp
// 定义了 traceId 的具体实现 16 字节数组
namespace trace {
class TraceId final {
public:
  // The size in bytes of the TraceId.
  static constexpr int kSize = 16;
  // Populates the buffer with the lowercase base16 representation of the ID.
  void ToLowerBase16(nostd::span<char, 2 * kSize> buffer) const noexcept;
  // Returns a nostd::span of the ID.
  nostd::span<const uint8_t, kSize> Id() const noexcept;
  // Returns false if the TraceId is all zeros.
  bool IsValid() const noexcept;
  // Copies the opaque TraceId data to dest.
  void CopyBytesTo(nostd::span<uint8_t, kSize> dest) const noexcept;
  // ...
private:
  uint8_t rep_[kSize];
};
}
```

### trace_flags.h

```cpp
// 定义了 traceFlag 决定是否对某一 trace 采样
// 居然不是 bool 实现 而是 1 字节 char
namespace trace {
class TraceFlags final {
public:
  static constexpr uint8_t kIsSampled = 1;
  bool IsSampled() const noexcept;
  // Populates the buffer with the lowercase base16 representation of the flags.
  void ToLowerBase16(nostd::span<char, 2> buffer) const noexcept;
  // getter
  uint8_t flags() const noexcept;
  // Copies the TraceFlags to dest.
  void CopyBytesTo(nostd::span<uint8_t, 1> dest) const noexcept 
  // ...
private:
  uint8_t rep_;
};
}
```

### trace_state.h

```cpp
// 携带与追踪链系统相关的上下文，本质时键值对列表 注意是列表！
// for more info https://www.w3.org/TR/trace-context version-traceid-parentid-traceflag
namespace trace {
class TraceState {
  // Returns shared_ptr to a newly created TraceState parsed from the header provided.
  static nostd::shared_ptr<TraceState> FromHeader(nostd::string_view header);
  // Creates a w3c tracestate header from TraceState object
  std::string ToHeader();
  // get
  bool Get(nostd::string_view key, std::string &value) const noexcept;
  // set
  nostd::shared_ptr<TraceState> Set(const nostd::string_view &key, const nostd::string_view &value);
  // del
  nostd::shared_ptr<TraceState> Delete(const nostd::string_view &key);
  // Returns true if there are no keys, false otherwise.
  bool Empty() const noexcept;
  // 如果需要再看吧
  bool GetAllEntries(
      nostd::function_ref<bool(nostd::string_view, nostd::string_view)> callback) const noexcept;
  // ...
private:
  // Store entries in a C-style array to avoid using std::array or std::vector.
  nostd::unique_ptr<opentelemetry::common::KeyValueProperties> kv_properties_;
};
}
```

### span_context.h

```cpp
// 包含里必须传递的上下文信息：traceid spanid traceflags tracestate
namespace trace {
class SpanContext final {
  // @returns whether this context is valid
  bool IsValid();
  // @returns the trace_flags associated with this span_context
  const opentelemetry::trace::TraceFlags &trace_flags() const noexcept;
  // @returns the trace_id associated with this span_context
  const opentelemetry::trace::TraceId &trace_id() const noexcept;
  // @returns the span_id associated with this span_context
  const opentelemetry::trace::SpanId &span_id() const noexcept;
  // @returns the trace_state associated with this span_context
  const nostd::shared_ptr<opentelemetry::trace::TraceState> trace_state() const noexcept;
  // true if this context was propagated from a remote parent
  bool IsRemote() const noexcep;
  // a required parameter specifying if child spans should be sampled
  bool IsSampled() const noexcep;
  // ...
private:
  opentelemetry::trace::TraceId trace_id_;
  opentelemetry::trace::SpanId span_id_;
  opentelemetry::trace::TraceFlags trace_flags_;
  bool is_remote_;
  nostd::shared_ptr<opentelemetry::trace::TraceState> trace_state_;
};
}
```

### span_metadata.h

```cpp
namespace trace {
// jaeger - tags "span.kind"
enum class SpanKind {
  kInternal,
  kServer,
  kClient,
  kProducer,
  kConsumer,
};

// The key identifies the active span in the current context.
constexpr char kSpanKey[] = "active_span";

// StatusCode - Represents the canonical set of status codes of a finished Span.
enum class StatusCode
{
  kUnset,  // default status
  kOk,     // Operation has completed successfully.
  kError   // The operation contains an error
};

/**
 * EndSpanOptions provides options to set properties of a Span when it is
 * ended.
 */
struct EndSpanOptions
{
  // Optionally sets the end time of a Span.
  common::SteadyTimestamp end_steady_time;
};
}
```

### span_startoptions.h

```cpp
namespace trace {
// 创建 span 时可以设置的属性
struct StartSpanOptions {
    // ...
};
}
```

### scope.h

```cpp
namespace trace {
// Controls how long a span is active.
class Scope final {
public:
  /**
   * Initialize a new scope.
   * @param span the given span will be set as the currently active span.
   */
  // constexpr char kSpanKey[] = "active_span";
  Scope(const nostd::shared_ptr<Span> &span) noexcept
      : token_(context::RuntimeContext::Attach(
            context::RuntimeContext::GetCurrent().SetValue(kSpanKey, span)))
  {}

private:
  nostd::unique_ptr<context::Token> token_;
};
}
```

### span.h -- Interface

```cpp
namespace trace {
// A Span represents a single operation within a Trace.
// Span Interface
// Span 默认是 threadlocal 存储
class Span {
  // 构造 应该通过 tracer 类获取 span，而不是使用构造函数
  // 拷贝和移动 全部禁止
  // Sets an attribute on the Span. If the Span previously contained a mapping
  // for the key, the old value is replaced.
  virtual void SetAttribute(nostd::string_view key,
                            const common::AttributeValue &value) noexcept = 0;
  // 一组 AdddEvent 的接口
  // Adds an event to the Span.
  virtual void AddEvent(nostd::string_view name) noexcept = 0;

  // Adds an event to the Span, with a custom timestamp.
  virtual void AddEvent(nostd::string_view name, common::SystemTimestamp timestamp) noexcept = 0;

  // Adds an event to the Span, with a custom timestamp, and attributes.
  virtual void AddEvent(nostd::string_view name,
                        common::SystemTimestamp timestamp,
                        const common::KeyValueIterable &attributes) noexcept = 0;
  // ...
  // Sets the status of the span. The default status is Unset. Only the value of
  // the last call will be
  // recorded, and implementations are free to ignore previous calls.
  virtual void SetStatus(StatusCode code, nostd::string_view description = "") noexcept = 0;
  // Updates the name of the Span. If used, this will override the name provided
  // during creation.
  virtual void UpdateName(nostd::string_view name) noexcept = 0;
  /**
   * Mark the end of the Span.
   * Only the timing of the first End call for a given Span will be recorded,
   * and implementations are free to ignore all further calls.
   * @param options can be used to manually define span properties like the end
   * timestamp
   */
  // EndSpanOptions 就是个时间戳啦
  virtual void End(const trace::EndSpanOptions &options = {}) noexcept = 0;
  // Return SpanContext
  virtual trace::SpanContext GetContext() const noexcept = 0;
  // Returns true if this Span is recording tracing events (e.g. SetAttribute,
  // AddEvent).
  virtual bool IsRecording() const noexcept = 0;
};
}
```

### default_span.h

```cpp
// 空实现
namespace trace {
class DefaultSpan : public Span {
    // ...
};
}
```

### trace.h -- Interface

```cpp
namespace trace{
// Handles span creation and in-process context propagation.
// 控制 context 创建和管理 span
// Tracer Interface
class Tracer {
  /**
   * Starts a span.
   *
   * Optionally sets attributes at Span creation from the given key/value pairs.
   *
   * Attributes will be processed in order, previous attributes with the same
   * key will be overwritten.
   */
  virtual nostd::shared_ptr<Span> StartSpan(nostd::string_view name,
                                            const common::KeyValueIterable &attributes,
                                            const SpanContextKeyValueIterable &links,
                                            const StartSpanOptions &options = {}) noexcept = 0;
  // 一组 StartSpan 接口 trace.name 必须指定，attr 添加 属性，links 添加相关的 spctx，opt 中可以指定 parent spancontext！

  // ...
  /**
   * Set the active span. The span will remain active until the returned Scope
   * object is destroyed.
   * @param span the span that should be set as the new active span.
   * @return a Scope that controls how long the span will be active.
   */
  // Scope 对象生命周期 = Span 跨度
  static Scope WithActiveSpan(nostd::shared_ptr<Span> &span) noexcept;
  /**
   * Get the currently active span.
   * @return the currently active span, or an invalid default span if no span
   * is active.
   */
  // 提供一种无需传递 Span 对象也可以获取当前 Span 的方法（前提是必须有 ActiveSpan）
  static nostd::shared_ptr<Span> GetCurrentSpan() noexcept;
  /**
   * Force any buffered spans to flush.
   * @param timeout to complete the flush
   */
  template <class Rep, class Period>
  void ForceFlush(std::chrono::duration<Rep, Period> timeout) noexcept;
  // ForceFlush 模板的内部实现
  virtual void ForceFlushWithMicroseconds(uint64_t timeout) noexcept = 0;
    /**
   * ForceFlush any buffered spans and stop reporting spans.
   * @param timeout to complete the flush
   */
  template <class Rep, class Period>
  void Close(std::chrono::duration<Rep, Period> timeout) noexcept;
  virtual void CloseWithMicroseconds(uint64_t timeout) noexcept = 0;
};
}
```

### trace_provider.h

```cpp
namespace trace {
// 创建 tracer 实例
class TracerProvider {
  // Gets or creates a named tracer instance.
  // Optionally a version can be passed to create a named and versioned tracer instance.
  virtual nostd::shared_ptr<Tracer> GetTracer(nostd::string_view library_name,
                                              nostd::string_view library_version = "",
                                              nostd::string_view schema_url      = "") = 0;

};
}
```

### provider.h

```cpp
namespace trace {
// Stores the singleton global TracerProvider.
class Provider{
  // Returns the singleton TracerProvider. 默认返回 no-op TracerProvider
  static nostd::shared_ptr<TracerProvider> GetTracerProvider() noexcept;
  // Changes the singleton TracerProvider.
  static void SetTracerProvider(nostd::shared_ptr<TracerProvider> tp) noexcept;
  // ...
};
}
```

## trace sdk

### recordable.h -- Interface & multi_recordable.h 扩展（不是严格意义上的实现）

```cpp
namespace sdk {
namespace trace {
using namespace opentelemetry::sdk::instrumentationlibrary;

// 线程安全的，可供recorder处理、管理span实现的类
class Recordable {
  // Set the span context and parent span id
  virtual void SetIdentity(const opentelemetry::trace::SpanContext &span_context,
                           opentelemetry::trace::SpanId parent_span_id) noexcept = 0;
  // Set an attribute of a span.
  virtual void SetAttribute(nostd::string_view key,
                            const opentelemetry::common::AttributeValue &value) noexcept = 0;
  // Add an event to a span.
  virtual void AddEvent(nostd::string_view name,
                        opentelemetry::common::SystemTimestamp timestamp,
                        const opentelemetry::common::KeyValueIterable &attributes) noexcept = 0;
  // 一组便捷函数
  void AddEvent(nostd::string_view name);
  void AddEvent(nostd::string_view name, opentelemetry::common::SystemTimestamp timestamp);
  // Add a link to a span. attr 是 link 属性
  virtual void AddLink(const opentelemetry::trace::SpanContext &span_context,
                       const opentelemetry::common::KeyValueIterable &attributes) noexcept = 0;
  // 一个便捷函数
  void AddLink(opentelemetry::trace::SpanContext span_context);
  // Set the status of the span. kUnset kOk KError
  virtual void SetStatus(opentelemetry::trace::StatusCode code,
                         nostd::string_view description) noexcept = 0;
  // Set the spankind of the span.
  virtual void SetName(nostd::string_view name) noexcept = 0;
  // Set the spankind of the span.
  virtual void SetSpanKind(opentelemetry::trace::SpanKind span_kind) noexcept = 0;
  // Set Resource of the span
  virtual void SetResource(const opentelemetry::sdk::resource::Resource &resource) noexcept = 0;
  // Set the start time of the span.
  virtual void SetStartTime(opentelemetry::common::SystemTimestamp start_time) noexcept = 0;
  // Set the duration of the span.
  virtual void SetDuration(std::chrono::nanoseconds duration) noexcept = 0;
  // Set the instrumentation library of the span.
  virtual void SetInstrumentationLibrary(
      const InstrumentationLibrary &instrumentation_library) noexcept = 0;
};

// Map 结构 processor 对象 -> recordable 对象
class MultiRecordable : public Recordable {
  // map set
  void AddRecordable(const SpanProcessor &processor,
                     std::unique_ptr<Recordable> recordable) noexcept;
  // map get
  const std::unique_ptr<Recordable> &GetRecordable(const SpanProcessor &processor) const noexcept;
  // map del
  std::unique_ptr<Recordable> ReleaseRecordable(const SpanProcessor &processor) noexcept;
  // override 遍历所有的 recordable 对象，并调用其 SetIdentity() 接口，其他同理
  void SetIdentity(const opentelemetry::trace::SpanContext &span_context,
                   opentelemetry::trace::SpanId parent_span_id) noexcept override;
  void SetAttribute(nostd::string_view key,
                    const opentelemetry::common::AttributeValue &value) noexcept override;
  void AddEvent(nostd::string_view name,
                opentelemetry::common::SystemTimestamp timestamp,
                const opentelemetry::common::KeyValueIterable &attributes) noexcept override;
  void AddLink(const opentelemetry::trace::SpanContext &span_context,
               const opentelemetry::common::KeyValueIterable &attributes) noexcept override;
  void SetStatus(opentelemetry::trace::StatusCode code,
                 nostd::string_view description) noexcept override;
  void SetName(nostd::string_view name) noexcept override;
  void SetSpanKind(opentelemetry::trace::SpanKind span_kind) noexcept override;
  void SetResource(const opentelemetry::sdk::resource::Resource &resource) noexcept override;
  void SetStartTime(opentelemetry::common::SystemTimestamp start_time) noexcept override;
  void SetDuration(std::chrono::nanoseconds duration) noexcept override;
  void SetInstrumentationLibrary(
      const InstrumentationLibrary &instrumentation_library) noexcept override;
  // ...
private:
  // std::size_t MakeKey(const SpanProcessor &processor); processor 转 key
  std::map<std::size_t, std::unique_ptr<Recordable>> recordables_;
};
}
}
```

### processor.h -- Interface & simple_process.h & batch_span_processor.h & multi_span_processor.h 实现

processor 持有 exporter 的实例，执行必要的前置处理操作（比如hook）后调用 exporter 的接口进行导出。

```cpp
namespace sdk {
namespace trace {
// Span processor allow hooks for span start and end method invocations.
// 也就是通过 hook 方式实现上报（导出）
class SpanProcessor {
  // Create a span recordable. This requests a new span recordable from the associated exporter.
  // 线程安全
  virtual std::unique_ptr<Recordable> MakeRecordable() noexcept = 0;
  // OnStart is called when a span is started.
  // Hook point 开启 Span
  virtual void OnStart(Recordable &span,
                       const opentelemetry::trace::SpanContext &parent_context) noexcept = 0;
  // OnEnd is called when a span is ended.
  // Hook point 关闭 Span
  virtual void OnEnd(std::unique_ptr<Recordable> &&span) noexcept = 0;
  // Export all ended spans that have not yet been exported.
  // 导出所有未上报 Span  default timeout of 0 means that no timeout is applied.
  virtual bool ForceFlush(
      std::chrono::microseconds timeout = (std::chrono::microseconds::max)()) noexcept = 0;
  // Shut down the processor and do any cleanup required. Ended spans are exported before shutdown.
  // After the call to Shutdown, subsequent calls to OnStart, OnEnd, ForceFlush or Shutdown will return immediately without doing anything.
  // 关停 Processor  default timeout of 0 means that no timeout is applied.
  virtual bool Shutdown(
      std::chrono::microseconds timeout = (std::chrono::microseconds::max)()) noexcept = 0;

};

// passes finished recordables to the configured SpanExporter, as soon as they are finished.
// OnEnd/ForceFlush 是 no-ops 实现， 所有的调用都会争抢基于 atomic_flag 实现的自旋锁
// 能用 但是不够完善（比如错误日志）
class SimpleSpanProcessor : public SpanProcessor {
  // 先配置导出器 再配置处理器
  explicit SimpleSpanProcessor(std::unique_ptr<SpanExporter> &&exporter) noexcept;
  // 
  std::unique_ptr<Recordable> MakeRecordable() noexcept override;
  void OnStart(Recordable &span,
               const opentelemetry::trace::SpanContext &parent_context) noexcept override;
  void OnEnd(std::unique_ptr<Recordable> &&span) noexcept override;
  bool ForceFlush(
      std::chrono::microseconds timeout = (std::chrono::microseconds::max)()) noexcept override;
  bool Shutdown(
      std::chrono::microseconds timeout = (std::chrono::microseconds::max)()) noexcept override;
  //...
};

// opt 队列最大长度，导出处理延迟，一次最大导出数量
struct BatchSpanProcessorOptions {
  size_t max_queue_size = 2048;
  std::chrono::milliseconds schedule_delay_millis = std::chrono::milliseconds(5000);
  size_t max_export_batch_size = 512;
};
// 在 Simple 版本上增加缓存功能，可以进行批量导出，该版本后台有个处理线程
class BatchSpanProcessor : public SpanProcessor {
  // 配置导出器和自身配置
  BatchSpanProcessor(std::unique_ptr<SpanExporter> &&exporter,
                     const BatchSpanProcessorOptions &options);
  std::unique_ptr<Recordable> MakeRecordable() noexcept override;
  void OnStart(Recordable &span,
               const opentelemetry::trace::SpanContext &parent_context) noexcept override;
  void OnEnd(std::unique_ptr<Recordable> &&span) noexcept override;
  bool ForceFlush(
      std::chrono::microseconds timeout = (std::chrono::microseconds::max)()) noexcept override;
  bool Shutdown(
      std::chrono::microseconds timeout = (std::chrono::microseconds::max)()) noexcept override;
  //...
};

struct MultiSpanProcessorOptions {
  // 还没想好给它加什么配置 哈哈哈
};
// Processor 链表，和上面两种实现不是并列关系（但是在继承体系里是同一位置）
// 也就是支持多个导出器共存 JaegerExporter/SimplePorcessor、OptlExporter/SimpleProcessor、、、
class MultiSpanProcessor : public SpanProcessor {
  // 允许添加多个 Processor
  MultiSpanProcessor(std::vector<std::unique_ptr<SpanProcessor>> &&processors);
  void AddProcessor(std::unique_ptr<SpanProcessor> &&processor);
  //
  std::unique_ptr<Recordable> MakeRecordable() noexcept override;
  virtual void OnStart(Recordable &span,
                       const opentelemetry::trace::SpanContext &parent_context) noexcept override;
  virtual void OnEnd(std::unique_ptr<Recordable> &&span) noexcept override
  bool ForceFlush(
      std::chrono::microseconds timeout = (std::chrono::microseconds::max)()) noexcept override;
  bool Shutdown(
      std::chrono::microseconds timeout = (std::chrono::microseconds::max)()) noexcept override;
  //...
};
}
}
```

### exporter.h -- Interface

```cpp
namespace sdk {
namespace trace {
  // Create a span recordable. This object will be used to record span data and
  // will subsequently be passed to SpanExporter::Export. Vendors can implement
  // custom recordables or use the default SpanData recordable provided by the SDK.
  // 线程安全
  virtual std::unique_ptr<Recordable> MakeRecordable() noexcept = 0;
  // Exports a batch of span recordables. This method must not be called
  // concurrently for the same exporter instance.
  // 非线程安全
  virtual sdk::common::ExportResult Export(
      const nostd::span<std::unique_ptr<opentelemetry::sdk::trace::Recordable>>
          &spans) noexcept = 0;
  // Shut down the exporter.
  virtual bool Shutdown(
      std::chrono::microseconds timeout = std::chrono::microseconds::max()) noexcept = 0;

}
}
```

### sampler.h -- Interface & always_off.h/always_on.h/parent.h/trace_id_ratio.h 实现


关闭用 alsway_off; 全采用 always_on; 其他用 parent(trace_id_ratio)，即根 Span 按比例开启，后续 Span 遵从上游决定

```cpp
namespace sdk {
namespace trace {
// 是否记录 是不是要走调用链处理流程
// 是否采样 是不是上报给exporter
enum class Decision {
  // IsRecording() == false, span will not be recorded and all events and attributes will be dropped.
  DROP,
  // IsRecording() == true, but Sampled flag MUST NOT be set.
  RECORD_ONLY,
  // IsRecording() == true AND Sampled flag` MUST be set.
  RECORD_AND_SAMPLE
};

struct SamplingResult
{
  Decision decision;
  // A set of span Attributes that will also be added to the Span. Can be nullptr.
  std::unique_ptr<const std::map<std::string, opentelemetry::common::AttributeValue>> attributes;
  // The tracestate used by the span.
  nostd::shared_ptr<opentelemetry::trace::TraceState> trace_state;
};

// 自定义采样器基类
class Sampler {
  // Called during Span creation to make a sampling decision.
  // 创建 Span 时调用
  virtual SamplingResult ShouldSample(
      const opentelemetry::trace::SpanContext &parent_context, // An invalid SpanContext if this is a root span.
      opentelemetry::trace::TraceId trace_id, // identical to that in the parentContext, unless this is a root span.
      nostd::string_view name,
      opentelemetry::trace::SpanKind span_kind,  // the opentelemetry::trace::SpanKind of the Span.
      const opentelemetry::common::KeyValueIterable &attributes, // list of AttributeValue with their keys.
      const opentelemetry::trace::SpanContextKeyValueIterable &links // Collection of links that will be associated with the Span to be created.
      ) noexcept = 0;

  // Returns the sampler name or short description with the configuration.
  virtual nostd::string_view GetDescription() const noexcept = 0;
};

// The always off sampler always returns DROP, effectively disabling tracing functionality.
class AlwaysOffSampler : public Sampler {
public:
  SamplingResult ShouldSample(
      const opentelemetry::trace::SpanContext &parent_context,
      opentelemetry::trace::TraceId /*trace_id*/,
      nostd::string_view /*name*/,
      opentelemetry::trace::SpanKind /*span_kind*/,
      const opentelemetry::common::KeyValueIterable & /*attributes*/,
      const opentelemetry::trace::SpanContextKeyValueIterable & /*links*/) noexcept override {
    if (!parent_context.IsValid()) {
      return {Decision::DROP, nullptr, opentelemetry::trace::TraceState::GetDefault()};
    } else {
      return {Decision::DROP, nullptr, parent_context.trace_state()};
    }
  }
  nostd::string_view GetDescription() const noexcept override {
    return "AlwaysOffSampler";
  }
};

class AlwaysOnSampler : public Sampler {
public:
  inline SamplingResult ShouldSample(
      const opentelemetry::trace::SpanContext &parent_context,
      opentelemetry::trace::TraceId /*trace_id*/,
      nostd::string_view /*name*/,
      opentelemetry::trace::SpanKind /*span_kind*/,
      const opentelemetry::common::KeyValueIterable & /*attributes*/,
      const opentelemetry::trace::SpanContextKeyValueIterable & /*links*/) noexcept override {
    if (!parent_context.IsValid()) {
      return {Decision::RECORD_AND_SAMPLE, nullptr, opentelemetry::trace::TraceState::GetDefault()};
    } else {
      return {Decision::RECORD_AND_SAMPLE, nullptr, parent_context.trace_state()};
    }
  }
  inline nostd::string_view GetDescription() const noexcept override {
    return "AlwaysOnSampler";
  }
};

// 根 Span 情况调用 delegate_sampler 决定，其他情况依据 parent_context
// parent_context (必须有效) -> sample_flag = 1 -> RECORD_AND_SAMPLE
class ParentBasedSampler : public Sampler {
public:
  explicit ParentBasedSampler(std::shared_ptr<Sampler> delegate_sampler) noexcept;
  SamplingResult ShouldSample(
      const opentelemetry::trace::SpanContext &parent_context,
      opentelemetry::trace::TraceId trace_id,
      nostd::string_view name,
      opentelemetry::trace::SpanKind span_kind,
      const opentelemetry::common::KeyValueIterable &attributes,
      const opentelemetry::trace::SpanContextKeyValueIterable &links) noexcept override;
  // "ParentBased{" + std::string{delegate_sampler->GetDescription()} + "}"
  nostd::string_view GetDescription() const noexcept override;

private:
  const std::shared_ptr<Sampler> delegate_sampler_;
  const std::string description_;
};

class TraceIdRatioBasedSampler : public Sampler {
public:
  // 1.0 >= ratio >= 0.0
  explicit TraceIdRatioBasedSampler(double ratio);
  // Returns either RECORD_AND_SAMPLE or DROP
  SamplingResult ShouldSample(
      const opentelemetry::trace::SpanContext & /*parent_context*/,
      opentelemetry::trace::TraceId trace_id,
      nostd::string_view /*name*/,
      opentelemetry::trace::SpanKind /*span_kind*/,
      const opentelemetry::common::KeyValueIterable & /*attributes*/,
      const opentelemetry::trace::SpanContextKeyValueIterable & /*links*/) noexcept override;
  // "TraceIdRatioBasedSampler{" + std::to_string(ratio) + "}"
  nostd::string_view GetDescription() const noexcept override;
};
}
}
```

### trace_context.h & tracer.h 实现 Tracer 类

```cpp
namespace sdk {
namespace trace {
// A class which stores the TracerProvider context.
// 线程！不完全！安全类  Processors/Exporters 的 owner/destroyer
class TracerContext
{
public:
  explicit TracerContext(
      std::vector<std::unique_ptr<SpanProcessor>> &&processor, // 使用 MultiSpanProcessor 管理
      opentelemetry::sdk::resource::Resource resource = opentelemetry::sdk::resource::Resource::Create({}),
      std::unique_ptr<Sampler> sampler = std::unique_ptr<AlwaysOnSampler>(new AlwaysOnSampler), // 持有 sampler
      std::unique_ptr<IdGenerator> id_generator = std::unique_ptr<IdGenerator>(new RandomIdGenerator())) noexcept;
  // Attaches a span processor to list of configured processors to this tracer context.
  // 添加了就不能移除 非线程安全（初始化时设置）
  // processor 的所有权会转移给该 TrarceContext
  // 调 processor 的接口
  void AddProcessor(std::unique_ptr<SpanProcessor> processor) noexcept;
  // Obtain the sampler associated with this tracer.
  Sampler &GetSampler() const noexcept;
  // Obtain the sampler associated with this tracer.
  SpanProcessor &GetProcessor() const noexcept;
  // Obtain the resource associated with this tracer context.
  const opentelemetry::sdk::resource::Resource &GetResource() const noexcept;
  // Obtain the Id Generator associated with this tracer context.
  opentelemetry::sdk::trace::IdGenerator &GetIdGenerator() const noexcept;
  // 调 processor 的接口
  // Force all active SpanProcessors to flush any buffered spans within the given timeout.
  bool ForceFlush(std::chrono::microseconds timeout = (std::chrono::microseconds::max)()) noexcept;
  // Shutdown the span processor associated with this tracer provider.
  // 调 processor 的接口
  bool Shutdown() noexcept;
private:
  // order of declaration is important here - resource object should be destroyed after processor.
  opentelemetry::sdk::resource::Resource resource_;
  std::unique_ptr<Sampler> sampler_;
  std::unique_ptr<IdGenerator> id_generator_;
  std::unique_ptr<SpanProcessor> processor_;
};

// enable_shared_from_this
// 当类A被share_ptr管理，且在类A的成员函数里需要把当前类对象作为参数传给其他函数时，就需要传递一个指向自身的share_ptr
// ! 应该使用 tracerprovider 来创建 tracer 实例
class Tracer final : public trace_api::Tracer, public std::enable_shared_from_this<Tracer> {
public:
  // Construct a new Tracer with the given context pipeline.
  explicit Tracer(std::shared_ptr<sdk::trace::TracerContext> context, // 包含 processor sampler id_generator resource
                  std::unique_ptr<InstrumentationLibrary> instrumentation_library =
                      InstrumentationLibrary::Create("")) noexcept;
  // 创建 Span 的正确方式
  nostd::shared_ptr<trace_api::Span> StartSpan(
      nostd::string_view name,
      const opentelemetry::common::KeyValueIterable &attributes,
      const trace_api::SpanContextKeyValueIterable &links,
      const trace_api::StartSpanOptions &options = {}) noexcept override;
  // (void)timeout;
  void ForceFlushWithMicroseconds(uint64_t timeout) noexcept override;
  // (void)timeout;
  void CloseWithMicroseconds(uint64_t timeout) noexcept override;
  // Returns the configured span processor.
  SpanProcessor &GetProcessor() noexcept { return context_->GetProcessor(); }
  // Returns the configured Id generator
  IdGenerator &GetIdGenerator() const noexcept { return context_->GetIdGenerator(); }
  // Returns the associated instruementation library
  const InstrumentationLibrary &GetInstrumentationLibrary() const noexcept
  {
    return *instrumentation_library_;
  }
  // Returns the currently configured resource
  const opentelemetry::sdk::resource::Resource &GetResource() { return context_->GetResource(); }
  // Note: Test only
  Sampler &GetSampler() { return context_->GetSampler(); }

private:
  // order of declaration is important here - instrumentation library should destroy after
  // tracer-context.
  std::shared_ptr<InstrumentationLibrary> instrumentation_library_;
  std::shared_ptr<sdk::trace::TracerContext> context_;
};
}
}
```

### trace_provider.h & 实现 TracerProvider 类

```cpp
namespace sdk {
namespace trace {
class TracerProvider final : public opentelemetry::trace::TracerProvider {
public:
  // Initialize a new tracer provider with a specified sampler
  // 单个 processor
  explicit TracerProvider(
      std::unique_ptr<SpanProcessor> processor,
      opentelemetry::sdk::resource::Resource resource =
          opentelemetry::sdk::resource::Resource::Create({}),
      std::unique_ptr<Sampler> sampler = std::unique_ptr<AlwaysOnSampler>(new AlwaysOnSampler),
      std::unique_ptr<opentelemetry::sdk::trace::IdGenerator> id_generator =
          std::unique_ptr<opentelemetry::sdk::trace::IdGenerator>(
              new RandomIdGenerator())) noexcept;
  // Initialize a new tracer provider with a specified sampler
  // 多个 processor
  explicit TracerProvider(
      std::vector<std::unique_ptr<SpanProcessor>> &&processors,
      opentelemetry::sdk::resource::Resource resource =
          opentelemetry::sdk::resource::Resource::Create({}),
      std::unique_ptr<Sampler> sampler = std::unique_ptr<AlwaysOnSampler>(new AlwaysOnSampler),
      std::unique_ptr<opentelemetry::sdk::trace::IdGenerator> id_generator =
          std::unique_ptr<opentelemetry::sdk::trace::IdGenerator>(
              new RandomIdGenerator())) noexcept;

  // Initialize a new tracer provider with a specified context
  explicit TracerProvider(std::shared_ptr<sdk::trace::TracerContext> context) noexcept;
  // 创建 tracer 的正确方法
  opentelemetry::nostd::shared_ptr<opentelemetry::trace::Tracer> GetTracer(
      nostd::string_view library_name,
      nostd::string_view library_version = "",
      nostd::string_view schema_url      = "") noexcept override;
  // Attaches a span processor to list of configured processors for this tracer provider.
  // 最好不要用，而是在初始化时就全部指定
  // 新增的 processor 只能获取到后续新创建的 Span
  // 线程不安全 实际上就是调用 Context 中 Processor 的 AddProcessor
  void AddProcessor(std::unique_ptr<SpanProcessor> processor) noexcept;
  // Obtain the resource associated with this tracer provider.
  // 实际上就是调用 Context 中 Processor 的方法
  const opentelemetry::sdk::resource::Resource &GetResource() const noexcept;
  // Shutdown the span processor associated with this tracer provider.
  // 实际上就是调用 Context 中 Processor 的方法
  bool Shutdown() noexcept;
  // Force flush the span processor associated with this tracer provider.
  // 实际上就是调用 Context 中 Processor 的方法
  bool ForceFlush(std::chrono::microseconds timeout = (std::chrono::microseconds::max)()) noexcept;

private:
  // order of declaration is important here - tracers should destroy only after context.
  std::vector<std::shared_ptr<opentelemetry::sdk::trace::Tracer>> tracers_;
  std::shared_ptr<sdk::trace::TracerContext> context_;
  std::mutex lock_;
}
}
}
```

### id_generator.h -- Interface & random_id_generator.h 实现

```cpp
namespace sdk {
namespace trace {
class IdGenerator {
public:
  /** Returns a SpanId represented by opaque 128-bit trace identifier */
  virtual opentelemetry::trace::SpanId GenerateSpanId() noexcept = 0;
  /** Returns a TraceId represented by opaque 64-bit trace identifier */
  virtual opentelemetry::trace::TraceId GenerateTraceId() noexcept = 0;
};

class RandomIdGenerator : public IdGenerator {
public:
  opentelemetry::trace::SpanId GenerateSpanId() noexcept override;
  opentelemetry::trace::TraceId GenerateTraceId() noexcept override;
};

}
}
```

### span_data.h & 实现 Recordable 类

```cpp
namespace sdk {
namespace trace {
// Class for storing events in SpanData.
class SpanDataEvent{
// ...
private:
  std::string name_;
  opentelemetry::common::SystemTimestamp timestamp_;
  common::AttributeMap attribute_map_;
};

// Class for storing links in SpanData.
class SpanDataLink {
// ...
private:
  opentelemetry::trace::SpanContext span_context_;
  common::AttributeMap attribute_map_;
};

// SpanData is a representation of all data collected by a span.
class SpanData final : public Recordable
{
public:
  SpanData() : resource_{nullptr}, instrumentation_library_{nullptr} {}
  // Get the trace id for this span
  opentelemetry::trace::TraceId GetTraceId() const noexcept { return span_context_.trace_id(); }
  // Get the span id for this span
  opentelemetry::trace::SpanId GetSpanId() const noexcept { return span_context_.span_id(); }
  // Get the span context for this span
  const opentelemetry::trace::SpanContext &GetSpanContext() const noexcept { return span_context_; }
  //  Get the parent span id for this span
  opentelemetry::trace::SpanId GetParentSpanId() const noexcept { return parent_span_id_; }
  // Get the name for this span
  opentelemetry::nostd::string_view GetName() const noexcept { return name_; }
  // Get the kind of this span
  opentelemetry::trace::SpanKind GetSpanKind() const noexcept { return span_kind_; }
  // Get the status for this span
  opentelemetry::trace::StatusCode GetStatus() const noexcept { return status_code_; }
  // Get the status description for this span
  opentelemetry::nostd::string_view GetDescription() const noexcept { return status_desc_; }
  // Get the resource
  const opentelemetry::sdk::resource::Resource &GetResource() const noexcept;
  // Get the instrumentation library
  const opentelemetry::sdk::trace::InstrumentationLibrary &GetInstrumentationLibrary()
      const noexcept;
  // Get the start time for this span
  opentelemetry::common::SystemTimestamp GetStartTime() const noexcept { return start_time_; }
  // Get the duration for this span
  std::chrono::nanoseconds GetDuration() const noexcept { return duration_; }
  // Get the attributes for this span
  const std::unordered_map<std::string, common::OwnedAttributeValue> &GetAttributes() const noexcept;
  // Get the events associated with this span
  const std::vector<SpanDataEvent> &GetEvents() const noexcept { return events_; }
  // Get the links associated with this span
  const std::vector<SpanDataLink> &GetLinks() const noexcept { return links_; }
  // override 实现
  // 同一个线程下使用 scope 对象激活 active span 即可自动实现
  // 跨边界传播使用这个方法吗？
  void SetIdentity(const opentelemetry::trace::SpanContext &span_context,
                   opentelemetry::trace::SpanId parent_span_id) noexcept override;
  void SetAttribute(nostd::string_view key,
                    const opentelemetry::common::AttributeValue &value) noexcept override;
  void AddEvent(nostd::string_view name,
                opentelemetry::common::SystemTimestamp timestamp =
                    opentelemetry::common::SystemTimestamp(std::chrono::system_clock::now()),
                const opentelemetry::common::KeyValueIterable &attributes =
                    opentelemetry::common::KeyValueIterableView<std::map<std::string, int>>(
                        {})) noexcept override;
  void AddLink(const opentelemetry::trace::SpanContext &span_context,
               const opentelemetry::common::KeyValueIterable &attributes) noexcept override;
  void SetStatus(opentelemetry::trace::StatusCode code,
                 nostd::string_view description) noexcept override;
  void SetName(nostd::string_view name) noexcept override;
  void SetSpanKind(opentelemetry::trace::SpanKind span_kind) noexcept override;
  void SetResource(const opentelemetry::sdk::resource::Resource &resource) noexcept override;
  void SetStartTime(opentelemetry::common::SystemTimestamp start_time) noexcept override;
  void SetDuration(std::chrono::nanoseconds duration) noexcept override;
  void SetInstrumentationLibrary(
      const InstrumentationLibrary &instrumentation_library) noexcept override;

private:
  opentelemetry::trace::SpanContext span_context_{false, false};
  opentelemetry::trace::SpanId parent_span_id_;
  opentelemetry::common::SystemTimestamp start_time_;
  std::chrono::nanoseconds duration_{0};
  std::string name_;
  opentelemetry::trace::StatusCode status_code_{opentelemetry::trace::StatusCode::kUnset};
  std::string status_desc_;
  common::AttributeMap attribute_map_;
  std::vector<SpanDataEvent> events_;
  std::vector<SpanDataLink> links_;
  opentelemetry::trace::SpanKind span_kind_{opentelemetry::trace::SpanKind::kInternal};
  const opentelemetry::sdk::resource::Resource *resource_;
  const InstrumentationLibrary *instrumentation_library_;
};
}
}
```

## exporters

### ostream

```cpp
namespace exporter {
namespace trace {
// The OStreamSpanExporter exports span data through an ostream
class OStreamSpanExporter final : public opentelemetry::sdk::trace::SpanExporter {
public:
  explicit OStreamSpanExporter(std::ostream &sout = std::cout) noexcept;
  // 创建 Span 用的
  // return std::unique_ptr<trace_sdk::Recordable>(new trace_sdk::SpanData);
  std::unique_ptr<opentelemetry::sdk::trace::Recordable> MakeRecordable() noexcept override;
  // 导出方法 输出到 stdout
  sdk::common::ExportResult OStreamSpanExporter::Export(
    const nostd::span<std::unique_ptr<trace_sdk::Recordable>> &spans) noexcept;
  // 
  bool OStreamSpanExporter::Shutdown(std::chrono::microseconds timeout) noexcept;
  bool OStreamSpanExporter::isShutdown() const noexcept;
  void OStreamSpanExporter::printAttributes(
      const std::unordered_map<std::string, sdkcommon::OwnedAttributeValue> &map,
      const std::string prefix);
  void OStreamSpanExporter::printEvents(const std::vector<trace_sdk::SpanDataEvent> &events);
  void OStreamSpanExporter::printLinks(const std::vector<trace_sdk::SpanDataLink> &links);
  void OStreamSpanExporter::printResources(const opentelemetry::sdk::resource::Resource &resources);
  void OStreamSpanExporter::printInstrumentationLibrary(
    const opentelemetry::sdk::instrumentationlibrary::InstrumentationLibrary
        &instrumentation_library);
};
}
}
```

### jaeger

```cpp
namespace exporter {
namespace jaeger {
enum class TransportFormat {
  kThriftUdp,
  kThriftUdpCompact,
  kThriftHttp,
  kProtobufGrpc,
};

struct JaegerExporterOptions
{
  TransportFormat transport_format = TransportFormat::kThriftUdpCompact;
  std::string endpoint             = "localhost";
  uint16_t server_port             = 6831;
  // Only applicable when using kThriftHttp transport.
  ext::http::client::Headers headers;
};

class JaegerExporter final : public opentelemetry::sdk::trace::SpanExporter {
public:
  explicit JaegerExporter(const JaegerExporterOptions &options);
  // Create a span recordable.
  // return std::unique_ptr<sdk::trace::Recordable>(new JaegerRecordable);
  std::unique_ptr<opentelemetry::sdk::trace::Recordable> MakeRecordable() noexcept override;
  // Export a batch of spans.
  opentelemetry::sdk::common::ExportResult Export(
      const nostd::span<std::unique_ptr<opentelemetry::sdk::trace::Recordable>> &spans) noexcept
      override;
  // Shutdown the exporter.
  bool Shutdown(
      std::chrono::microseconds timeout = std::chrono::microseconds::max()) noexcept override;
  // ...
};

// 
class JaegerRecordable final : public sdk::trace::Recordable {
public:
  JaegerRecordable();

  thrift::Span *Span() noexcept { return span_.release(); }
  std::vector<thrift::Tag> Tags() noexcept { return std::move(tags_); }
  std::vector<thrift::Tag> ResourceTags() noexcept { return std::move(resource_tags_); }
  std::vector<thrift::Log> Logs() noexcept { return std::move(logs_); }
  const std::string &ServiceName() const noexcept { return service_name_; }

  void SetIdentity(const opentelemetry::trace::SpanContext &span_context,
                   opentelemetry::trace::SpanId parent_span_id) noexcept override;
  // 写入 tag
  void SetAttribute(nostd::string_view key,
                    const opentelemetry::common::AttributeValue &value) noexcept override;
  // 写入 tag "event"
  void AddEvent(nostd::string_view key,
                common::SystemTimestamp timestamp,
                const common::KeyValueIterable &attributes) noexcept override;
  // 未实现
  void AddLink(const opentelemetry::trace::SpanContext &span_context,
               const common::KeyValueIterable &attributes) noexcept override;
  // 写入 tag
  void SetStatus(trace::StatusCode code, nostd::string_view description) noexcept override;

  void SetName(nostd::string_view name) noexcept override;

  void SetStartTime(common::SystemTimestamp start_time) noexcept override;
  // 写入 tag "span.kind"
  void SetSpanKind(opentelemetry::trace::SpanKind span_kind) noexcept override;

  void SetResource(const opentelemetry::sdk::resource::Resource &resource) noexcept override;

  void SetDuration(std::chrono::nanoseconds duration) noexcept override;

  void SetInstrumentationLibrary(
      const opentelemetry::sdk::instrumentationlibrary::InstrumentationLibrary
          &instrumentation_library) noexcept override;

private:
  std::unique_ptr<thrift::Span> span_;
  std::vector<thrift::Tag> tags_;
  std::vector<thrift::Tag> resource_tags_;
  std::vector<thrift::Log> logs_;
  std::string service_name_;
};
}
}
```
