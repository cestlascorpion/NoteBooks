# Golang

## 3个环境变量

>- GOROOT：Go 语⾔安装根⽬录的路径，也就是 GO 语⾔的安装路径。
>- GOPATH：若⼲⼯作区⽬录的路径。是我们⾃⼰定义的⼯作空间。
>- GOBIN：GO 程序⽣成的可执⾏⽂件（executable file）的路径。

GOPATH 可以简单理解成 Go 语⾔的⼯作⽬录，它的值是⼀个⽬录的路径，也可以是多个⽬录路径，每个⽬录都代表 Go 语⾔的⼀个⼯作区（workspace）。

与许多编程语⾔⼀样，Go 语⾔的源码也是以代码包为基本组织单位的。在⽂件系统中，这些代码包其实是与⽬录⼀⼀对应的。由于⽬录可以有⼦⽬录，所以代码包也可以有⼦包。
⼀个代码包中可以包含任意个以.go 为扩展名的源码⽂件，这些源码⽂件都需要被声明属于同⼀个代码包。代码包的名称⼀般会与源码⽂件所在的⽬录同名。如果不同名，那么在构建、安装的过程中会以代码包名称为准。

每个代码包都会有导⼊路径。代码包的导⼊路径是其他代码在使⽤该包中的程序实体时，需
要引⼊的路径。在实际使⽤程序实体之前，我们必须先导⼊其所在的代码包。具体的⽅式就
是import该代码包的导⼊路径。

在⼯作区中，⼀个代码包的导⼊路径实际上就是从 src ⼦⽬录，到该包的实际存储位置的
相对路径。所以说，Go 语⾔源码的组织⽅式就是以环境变量 GOPATH、⼯作区、src ⽬录和代码包为主线的。⼀般情况下，Go 语⾔的源码⽂件都需要被存放在环境变量 GOPATH 包含的某个
⼯作区（⽬录）中的 src ⽬录下的某个代码包（⽬录）中。

## HelloWorld

如果⼀个源码⽂件声明属于main包，并且包含⼀个⽆参数声明且⽆结果声明的main函数，
那么它就是命令源码⽂件。当需要模块化编程时，我们往往会将代码拆分到多个⽂件，甚⾄拆分到不同的代码包中。但⽆论怎样，对于⼀个独⽴的程序来说，命令源码⽂件永远只会也只能有⼀个。如果有与命令源码⽂件同包的源码⽂件，那么它们也应该声明属于main包。

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, 世界")
}
```

## 语言基础

### 变量和常量

整型: int 4/8字节 uint 4/8字节 int8/uint8 1字节 int16/uint16 2字节 int32/uint32 4字节 int64/uint64 8字节

浮点型: float32/float64

复数型: complex64/complex128 complex64类型的值会由两个float32类型的值分别表示复数的实数部分和虚数部分。而complex128类型的值会由两个float64类型的值表示复数的实数部分和虚数部分。负数类型的值一般由浮点数表示的实数部分、加号"+"、浮点数表示的虚数部分以及小写字母"i"组成，比如3.9E+1 + 9.99E-2i。

字符串类型: string 字符串的表示法有两种，即：原生表示法和解释型表示法。原生表示法，需用用反引号"`"把字符序列包起来，如果用解释型表示法，则需要用双引号"""包裹字符序列。二者的区别是，前者表示的是所见即所得的(除了回车符)。后者所表示的值中转义符会起作用。字符串值是不可变的，如果我们创建了一个此类型的值，就不可能再对它本身做任何修改。

别名类型: byte rune byte与rune都属于别名类型。byte是uint8的别名类型，而rune是int32的别名类型。一个rune的类型值即可表示一个Unicode字符。一个Unicode代码点通常由"U+"和一个以十六进制表示法表示的整数表示，例如英文字母'A'的Unicode代码点为"U+0041”。rune类型的值需要由单引号"'"包裹。

```go
var num int = 1
var num1, num2 int = 1, 2
var (
    num int    = 1
    name string = "name"
)
var num8 int = 032 // 八进制
var num16 int = 0x32  // 十六进制 

var numf1 float32 = 2E-2  // 0.02 
var numf2 float32 = 2E+2  // 200

var str1 string = "str"
var str2 string = `str`
```

数组类型: [长度]类型 eg: [3]int 一个数组是可以容纳若干相同类型的元素的容器。数组的长度是固定的。使用下标读写任意元素，len获取长度。如果一个数组没有赋值，，则它的默认值[length]type{0, 0, 0 …}，总之不是nil。

切片类型: []类型 eg: []int 切片(slice)与数组一样也是可以若干相同类型元素的容器。与数组不同的是切片类型的长度不确定。每个切片值都会将数组作为其底层数据结构。

操作数组值的方法同样适用于切片值。还有一种操作数组的方式叫做“切片”，实施切片操作的方式就是切片表达式。除了长度切片值以及数组值还有另外一个属性：容量。数组的容量总是等于其长度，而切片值的容量往往与其长度不同，而是等于底层数组的长度。可以使用cap()内建函数获取数组、切片、通道类型的值的容量。

append会对切片值进行扩展并返回一个新的切片值。一旦扩展操作超出了被操作的切片值的容量，那么该切片的底层数组就会被替换 最后一种操作切片的方式是“复制”。该操作的实施方法是调用copy函数。该函数接收两个类型相同的切片值作为参数，并把第二个参数值中的元素复制到第一个参数值中的相应位置(索引值相同)上。

这种复制遵循最小复制原则，即：被复制的元素的个数总是等于长度较短的那个参值的长度。与append函数不同，copy函数会直接对其第一个参数值进行修改。

切片属于引用类型，零值为nil。

```go
var array1 = [3]int{1,2,3}
var array2 = [...]int{1,2,3}

var slice1 = []int{1,2,3}

var array2 = [5]int{1,2,3,4,5}
var slice2 = array2[1:4] // 使用索引[1,4)构建 此切片的容量为4

var array3 = [5]int{1,2,3,4,5}
var slice1 = array3[1:4:4] // 第三个整数为索引的上界 此切片的容量为3
```

字典类型 map[key类型]value类型 eg: map[string]int 字典的键类型必须是可比较的，否则会引起错误，即键不能是切片、字典、函数类型。字典值的字面量表示法实际上与数组的切片的字面量表示法很相似。最左边仍然是类型字面量，右边紧挨着由花括号包裹且有英文逗号分隔的键值对。每个键值对的键和值之间由冒号分隔。

对于字典值来说，如果指定键没有对应的值则默认为该类型的空值。 从字典中删除键值对的方法非常简单，仅仅是调用内建函数delete，即delete(m, key)。

字典类型属于引用类型，它的零值即为nil

```go
mm := map[int]string{1:"a",2:"b"m,3:"c"}
e, ok := mm[5] // ok = false
```

通道类型 chan 类型 通道(Channel)是Go语言中一种非常独特的数据结构。它可用于在不同Goroutine之间传递类型化的数据。并且是并发安全的。相比之下，之前几种数据类型都不是并发安全的。
Goroutine可以被看作是承载可被并发执行的代码块的载体。它们由Go语言的运行时系统调度，并依托操作系统线程(又称内核线程)来并发地执行其中的代码块。

与其他的数据类型不同，我们无法表示一个通道类型的值，因此，我们无法用字面量来为通道类型的变量赋值。只能通过调用内建函数make来达到目的。make参数可接受两个参数，第一个参数是代表了将被初始化的值的类型的字面量，第二个参数则是值的长度。make函数也可以被用来初始化切片类型或字典类型的值。可以通过函数close来关闭通道。

在通道值有效的前提下，针对它的发送操作会在通道值已满(其中缓存的数据的个数已等于它的长度)时被阻塞。而向一个已被关闭的通道值发送数据会引发运行时异常。针对有效通道值的接收操作会在它已经为空时被阻塞。

通道类型属于引用类型，它的零值为nil。

```go
ch := make(chan int, 5)
slice := make([]int, 5)
mm := make(map[string]int)

fmt.Println(ch, slice, mm)
// 0xc00007e000 [0 0 0 0 0] map[]

ch <- 1 // 发送数据
c, ok := <- ch // 接受数据
```

这里的ok的值是bool类型的。它代表了通道值的状态，true代表通道值有效，而false则代表通道值已无效(或称已关闭)，更深层次的原因是，如果在接受操作进行之前或过程中通道值被关闭了，则接收操作会立即结束并返回一个该通道值的元素类型的零值。
