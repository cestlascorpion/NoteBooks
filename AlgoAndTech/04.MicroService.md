# 微服务

## 限流

限流指的是通过限制到达系统的并发请求数量，保证系统能够正常响应部分⽤户请求，⽽对于超过限制的流量，则只能通过拒绝服务的⽅式保证整体系统的可⽤性。限流策略⼀般部署在服务的⼊⼝层，⽐如 API ⽹关中，这样可以对系统整体流量做塑形。⽽在微服务架构中，你也可以在 RPC 客户端中引⼊限流的策略，来保证单个服务不会被过⼤的流量压垮。

常见的限流算法有固定窗⼝与滑动窗⼝的算法、漏桶算法与令牌筒算法。限流是⼀种常⻅的服务保护策略，你可以在整体服务、单个服务、单个接⼝、单个 IP 或者单个⽤户等多个维度进⾏流量的控制。基于时间窗⼝维度的算法有固定窗⼝算法和滑动窗⼝算法，两者虽然能⼀定程度上实现限流的⽬的，但是都⽆法让流量变得更平滑；令牌桶算法和漏桶算法则能够塑形流量，让流量更加平滑，但是令牌桶算法能够应对⼀定的突发流量，所以在实际项⽬中应⽤更多。

## 熔断

当下游的服务因为某种原因突然变得不可用或响应过慢，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。

需要说明的是熔断其实是一个框架级的处理，那么这套熔断机制的设计，基本上业内用的是断路器模式。

在这种模式下，服务调⽤⽅为每⼀个调⽤的服务维护⼀个有限状态机，在这个状态机中会有三种状态：关闭（调⽤远程服务）、半打开（尝试调⽤远程服务）和打开（返回错误）。这三种状态之间切换的过程是下⾯这个样⼦。

当调⽤失败的次数累积到⼀定的阈值时，熔断状态从关闭态切换到打开态。⼀般在实现时，如果调⽤成功⼀次，就会重置调⽤失败次数。当熔断处于打开状态时，我们会启动⼀个超时计时器，当计时器超时后，状态切换到半打开态。你也可以通过设置⼀个定时器，定期地探测服务是否恢复。

其实，不仅仅微服务之间调⽤需要熔断的机制，我们在调⽤ Redis、Memcached 等资源的时候也可以引⼊这套机制。在我的团队⾃⼰封装的 Redis 客户端中，就实现了⼀套简单的熔断机制。⾸先，在系统初始化的时候，我们定义了⼀个定时器，当熔断器处于 Open 状态时，定期地检测 Redis 组件是否可⽤：在熔断处于半打开状态时，请求可以达到后端服务，如果累计⼀定的成功次数后，状态切换到关闭态；如果出现调⽤失败的情况，则切换到打开态。

## 降级

相⽐熔断来说，降级是⼀个更⼤的概念。因为它是站在整体系统负载的⻆度上，放弃部分⾮核⼼功能或者服务，保证整体的可⽤性的⽅法，是⼀种有损的系统容错⽅式。这样看来，熔断也是降级的⼀种，除此之外还有限流降级、开关降级等等。

开关降级指的是在代码中预先埋设⼀些“开关”，⽤来控制服务调⽤的返回值。⽐⽅说，开关关闭的时候正常调⽤远程服务，开关打开时则执⾏降级的策略。这些开关的值可以存储在配置中⼼中，当系统出现问题需要降级时，只需要通过配置中⼼动态更改开关的值，就可以实现不重启服务快速地降级远程服务了。

熔断和降级的相似：目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段。

熔断和降级的区别：触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）实现方式不太一样。
